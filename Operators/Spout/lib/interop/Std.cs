// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Security;
using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

[assembly:InternalsVisibleTo("SpoutDX")]

#pragma warning disable CS0109 // Member does not hide an inherited member; new keyword is not required

// DEBUG: struct tagRECT
// DEBUG: {
// DEBUG:     LONG    left;
// DEBUG:     LONG    top;
// DEBUG:     LONG    right;
// DEBUG:     LONG    bottom;
// DEBUG: }
public unsafe partial class TagRECT
{
    [StructLayout(LayoutKind.Sequential, Size = 16)]
    public partial struct __Internal
    {
        internal int left;
        internal int top;
        internal int right;
        internal int bottom;
    }
}

// DEBUG: struct tagSIZE
// DEBUG: {
// DEBUG:     LONG        cx;
// DEBUG:     LONG        cy;
// DEBUG: }
public unsafe partial class TagSIZE
{
    [StructLayout(LayoutKind.Sequential, Size = 8)]
    public partial struct __Internal
    {
        internal int cx;
        internal int cy;
    }
}

// DEBUG: struct _GUID {
// DEBUG:     unsigned long  Data1;
// DEBUG:     unsigned short Data2;
// DEBUG:     unsigned short Data3;
// DEBUG:     unsigned char  Data4[ 8 ];
// DEBUG: }
public unsafe partial class GUID
{
    [StructLayout(LayoutKind.Sequential, Size = 16)]
    public partial struct __Internal
    {
        internal uint Data1;
        internal ushort Data2;
        internal ushort Data3;
        internal fixed byte Data4[8];
    }
}

// DEBUG: struct _SHELLEXECUTEINFOA
// DEBUG: {
// DEBUG:     DWORD cbSize;               // in, required, sizeof of this structure
// DEBUG:     ULONG fMask;                // in, SEE_MASK_XXX values
// DEBUG:     HWND hwnd;                  // in, optional
// DEBUG:     LPCSTR   lpVerb;            // in, optional when unspecified the default verb is choosen
// DEBUG:     LPCSTR   lpFile;            // in, either this value or lpIDList must be specified
// DEBUG:     LPCSTR   lpParameters;      // in, optional
// DEBUG:     LPCSTR   lpDirectory;       // in, optional
// DEBUG:     int nShow;                  // in, required
// DEBUG:     HINSTANCE hInstApp;         // out when SEE_MASK_NOCLOSEPROCESS is specified
// DEBUG:     void *lpIDList;             // in, valid when SEE_MASK_IDLIST is specified, PCIDLIST_ABSOLUTE, for use with SEE_MASK_IDLIST & SEE_MASK_INVOKEIDLIST
// DEBUG:     LPCSTR   lpClass;           // in, valid when SEE_MASK_CLASSNAME is specified
// DEBUG:     HKEY hkeyClass;             // in, valid when SEE_MASK_CLASSKEY is specified
// DEBUG:     DWORD dwHotKey;             // in, valid when SEE_MASK_HOTKEY is specified
// DEBUG:     union
// DEBUG:     {
// DEBUG:         HANDLE hIcon;           // not used
// DEBUG: #if (NTDDI_VERSION >= NTDDI_WIN2K)
// DEBUG:         HANDLE hMonitor;        // in, valid when SEE_MASK_HMONITOR specified
// DEBUG: #endif // (NTDDI_VERSION >= NTDDI_WIN2K)
// DEBUG:     } DUMMYUNIONNAME;
// DEBUG:     HANDLE hProcess;            // out, valid when SEE_MASK_NOCLOSEPROCESS specified
// DEBUG: }
public unsafe partial class SHELLEXECUTEINFOA
{
    [StructLayout(LayoutKind.Sequential, Size = 112)]
    public partial struct __Internal
    {
        internal uint cbSize;
        internal uint fMask;
        internal __IntPtr hwnd;
        internal __IntPtr lpVerb;
        internal __IntPtr lpFile;
        internal __IntPtr lpParameters;
        internal __IntPtr lpDirectory;
        internal int nShow;
        internal __IntPtr hInstApp;
        internal __IntPtr lpIDList;
        internal __IntPtr lpClass;
        internal __IntPtr hkeyClass;
        internal uint dwHotKey;
        internal global::SHELLEXECUTEINFOA._0.__Internal _0;
        internal __IntPtr hProcess;
    }

    // DEBUG: union
    // DEBUG:     {
    // DEBUG:         HANDLE hIcon;           // not used
    // DEBUG: #if (NTDDI_VERSION >= NTDDI_WIN2K)
    // DEBUG:         HANDLE hMonitor;        // in, valid when SEE_MASK_HMONITOR specified
    // DEBUG: #endif // (NTDDI_VERSION >= NTDDI_WIN2K)
    // DEBUG:     }
    public unsafe partial struct _0
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal __IntPtr hIcon;

            [FieldOffset(0)]
            internal __IntPtr hMonitor;
        }
    }
}

namespace Spout.Std
{
    namespace BasicString
    {
        [StructLayout(LayoutKind.Sequential, Size = 32, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C
        {
            internal global::Spout.Std.CompressedPair.__Internalc__N_std_S__Compressed_pair____N_std_S_allocator__C___N_std_S__String_val____N_std_S__Simple_types__C_Vb1 _Mypair;

            [SuppressUnmanagedCodeSecurity, DllImport("Std-symbols", EntryPoint = "??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctorc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Std-symbols", EntryPoint = "??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void dtorc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C(__IntPtr __instance);
        }
    }

    // DEBUG: class basic_string { // null-terminated transparent array of elements
    // DEBUG: private:
    // DEBUG:     friend _Tidy_deallocate_guard<basic_string>;
    // DEBUG:     friend basic_stringbuf<_Elem, _Traits, _Alloc>;
    // DEBUG: 
    // DEBUG:     using _Alty        = _Rebind_alloc_t<_Alloc, _Elem>;
    // DEBUG:     using _Alty_traits = allocator_traits<_Alty>;
    // DEBUG: 
    // DEBUG:     using _Scary_val = _String_val<conditional_t<_Is_simple_alloc_v<_Alty>, _Simple_types<_Elem>,
    // DEBUG:         _String_iter_types<_Elem, typename _Alty_traits::size_type, typename _Alty_traits::difference_type,
    // DEBUG:             typename _Alty_traits::pointer, typename _Alty_traits::const_pointer>>>;
    // DEBUG: 
    // DEBUG:     static_assert(!_ENFORCE_MATCHING_ALLOCATORS || is_same_v<_Elem, typename _Alloc::value_type>,
    // DEBUG:         _MISMATCHED_ALLOCATOR_MESSAGE("basic_string<T, Traits, Allocator>", "T"));
    // DEBUG: 
    // DEBUG:     static_assert(is_same_v<_Elem, typename _Traits::char_type>,
    // DEBUG:         "N4950 [string.require]/3 requires that the supplied "
    // DEBUG:         "char_traits character type match the string's character type.");
    // DEBUG: 
    // DEBUG:     static_assert(!is_array_v<_Elem> && is_trivial_v<_Elem> && is_standard_layout_v<_Elem>,
    // DEBUG:         "The character type of basic_string must be a non-array trivial standard-layout type. See N4950 "
    // DEBUG:         "[strings.general]/1.");
    // DEBUG: 
    // DEBUG: public:
    // DEBUG:     using traits_type    = _Traits;
    // DEBUG:     using allocator_type = _Alloc;
    // DEBUG: 
    // DEBUG:     using value_type      = _Elem;
    // DEBUG:     using size_type       = typename _Alty_traits::size_type;
    // DEBUG:     using difference_type = typename _Alty_traits::difference_type;
    // DEBUG:     using pointer         = typename _Alty_traits::pointer;
    // DEBUG:     using const_pointer   = typename _Alty_traits::const_pointer;
    // DEBUG:     using reference       = value_type&;
    // DEBUG:     using const_reference = const value_type&;
    // DEBUG: 
    // DEBUG:     using iterator       = _String_iterator<_Scary_val>;
    // DEBUG:     using const_iterator = _String_const_iterator<_Scary_val>;
    // DEBUG: 
    // DEBUG:     using reverse_iterator       = _STD reverse_iterator<iterator>;
    // DEBUG:     using const_reverse_iterator = _STD reverse_iterator<const_iterator>;
    // DEBUG: 
    // DEBUG: private:
    // DEBUG:     static constexpr size_type _BUF_SIZE              = _Scary_val::_BUF_SIZE;
    // DEBUG:     static constexpr size_type _Alloc_mask            = _Scary_val::_Alloc_mask;
    // DEBUG:     static constexpr size_type _Small_string_capacity = _Scary_val::_Small_string_capacity;
    // DEBUG: 
    // DEBUG:     // least real allocation size, including space reserved for terminating null
    // DEBUG:     static constexpr size_type _Least_allocation_size = _Small_string_capacity + 1 + 1;
    // DEBUG: 
    // DEBUG:     // When doing _String_val operations by memcpy, we are touching:
    // DEBUG:     //   _String_val::_Bx::_Buf (type is array of _Elem)
    // DEBUG:     //   _String_val::_Bx::_Ptr (type is pointer)
    // DEBUG:     //   _String_val::_Mysize   (type is size_type)
    // DEBUG:     //   _String_val::_Myres    (type is size_type)
    // DEBUG:     // N4950 [strings.general]/1 says _Elem must be trivial standard-layout, so memcpy is safe.
    // DEBUG:     // We need to ask if pointer is safe to memcpy.
    // DEBUG:     // size_type must be an unsigned integral type so memcpy is safe.
    // DEBUG:     // We also need to disable memcpy if the user has supplied _Traits, since
    // DEBUG:     //   they can observe traits::assign and similar.
    // DEBUG:     static constexpr bool _Can_memcpy_val = _Is_specialization_v<_Traits, char_traits> && is_trivial_v<pointer>;
    // DEBUG:     // This offset skips over the _Container_base members, if any
    // DEBUG:     static constexpr size_t _Memcpy_val_offset = _Size_after_ebco_v<_Container_base>;
    // DEBUG:     static constexpr size_t _Memcpy_val_size   = sizeof(_Scary_val) - _Memcpy_val_offset;
    // DEBUG: 
    // DEBUG:     template <class _Iter>
    // DEBUG:     // TRANSITION, /clr:pure is incompatible with templated static constexpr data members
    // DEBUG:     // static constexpr bool _Is_elem_cptr =_Is_any_of_v<_Iter, const _Elem* const, _Elem* const, const _Elem*, _Elem*>;
    // DEBUG:     using _Is_elem_cptr = bool_constant<_Is_any_of_v<_Iter, const _Elem* const, _Elem* const, const _Elem*, _Elem*>>;
    // DEBUG: 
    // DEBUG: #if _HAS_CXX17
    // DEBUG:     template <class _StringViewIsh>
    // DEBUG:     using _Is_string_view_ish =
    // DEBUG:         enable_if_t<conjunction_v<is_convertible<const _StringViewIsh&, basic_string_view<_Elem, _Traits>>,
    // DEBUG:                         negation<is_convertible<const _StringViewIsh&, const _Elem*>>>,
    // DEBUG:             int>;
    // DEBUG: #endif // _HAS_CXX17
    // DEBUG: 
    // DEBUG: #ifdef _INSERT_STRING_ANNOTATION
    // DEBUG:     _CONSTEXPR20 void _Create_annotation() const noexcept {
    // DEBUG:         // Annotates the valid range with shadow memory
    // DEBUG:         auto& _My_data = _Mypair._Myval2;
    // DEBUG:         _Apply_annotation(_My_data._Myptr(), _My_data._Myres, _My_data._Myres, _My_data._Mysize);
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _CONSTEXPR20 void _Remove_annotation() const noexcept {
    // DEBUG:         // Removes annotation of the range with shadow memory
    // DEBUG:         auto& _My_data = _Mypair._Myval2;
    // DEBUG:         _Apply_annotation(_My_data._Myptr(), _My_data._Myres, _My_data._Mysize, _My_data._Myres);
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _CONSTEXPR20 void _Modify_annotation(const size_type _Old_size, const size_type _New_size) const noexcept {
    // DEBUG:         if (_Old_size == _New_size) {
    // DEBUG:             return;
    // DEBUG:         }
    // DEBUG: 
    // DEBUG:         auto& _My_data = _Mypair._Myval2;
    // DEBUG:         _Apply_annotation(_My_data._Myptr(), _My_data._Myres, _Old_size, _New_size);
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     static _CONSTEXPR20 void _Apply_annotation(const value_type* const _First, const size_type _Capacity,
    // DEBUG:         const size_type _Old_size, const size_type _New_size) noexcept {
    // DEBUG: #if _HAS_CXX20
    // DEBUG:         if (_STD is_constant_evaluated()) {
    // DEBUG:             return;
    // DEBUG:         }
    // DEBUG: #endif // _HAS_CXX20
    // DEBUG:        // Don't annotate small strings; only annotate on the heap.
    // DEBUG:         if (_Capacity <= _Small_string_capacity || !_Asan_string_should_annotate) {
    // DEBUG:             return;
    // DEBUG:         }
    // DEBUG: 
    // DEBUG:         // Note that `_Capacity`, `_Old_size`, and `_New_size` do not include the null terminator
    // DEBUG:         const void* const _End      = _First + _Capacity + 1;
    // DEBUG:         const void* const _Old_last = _First + _Old_size + 1;
    // DEBUG:         const void* const _New_last = _First + _New_size + 1;
    // DEBUG: 
    // DEBUG:         constexpr bool _Large_string_always_asan_aligned =
    // DEBUG:             (_Container_allocation_minimum_asan_alignment<basic_string>) >= _Asan_granularity;
    // DEBUG: 
    // DEBUG:         // for the non-aligned buffer options, the buffer must always have size >= 9 bytes,
    // DEBUG:         // so it will always end at least one shadow memory section.
    // DEBUG: 
    // DEBUG:         _Asan_aligned_pointers _Aligned;
    // DEBUG:         if constexpr (_Large_string_always_asan_aligned) {
    // DEBUG:             _Aligned = {_First, _STD _Get_asan_aligned_after(_End)};
    // DEBUG:         } else {
    // DEBUG:             _Aligned = _STD _Get_asan_aligned_first_end(_First, _End);
    // DEBUG:         }
    // DEBUG:         const void* const _Old_fixed = _Aligned._Clamp_to_end(_Old_last);
    // DEBUG:         const void* const _New_fixed = _Aligned._Clamp_to_end(_New_last);
    // DEBUG: 
    // DEBUG:         // --- always aligned case ---
    // DEBUG:         // old state:
    // DEBUG:         //   [_First, _Old_last) valid
    // DEBUG:         //   [_Old_last, asan_aligned_after(_End)) poison
    // DEBUG:         // new state:
    // DEBUG:         //   [_First, _New_last) valid
    // DEBUG:         //   [_New_last, asan_aligned_after(_End)) poison
    // DEBUG: 
    // DEBUG:         // --- sometimes non-aligned case ---
    // DEBUG:         // old state:
    // DEBUG:         //   [_Aligned._First, _Old_fixed) valid
    // DEBUG:         //   [_Old_fixed, _Aligned._End) poison
    // DEBUG:         //   [_Aligned._End, _End) valid
    // DEBUG:         // new state:
    // DEBUG:         //   [_Aligned._First, _New_fixed) valid
    // DEBUG:         //   [_New_fixed, _Aligned._End) poison
    // DEBUG:         //   [_Aligned._End, _End) valid
    // DEBUG:         _CSTD __sanitizer_annotate_contiguous_container(_Aligned._First, _Aligned._End, _Old_fixed, _New_fixed);
    // DEBUG:     }
    // DEBUG: 
    // DEBUG: #define _ASAN_STRING_REMOVE(_Str)                       (_Str)._Remove_annotation()
    // DEBUG: #define _ASAN_STRING_CREATE(_Str)                       (_Str)._Create_annotation()
    // DEBUG: #define _ASAN_STRING_MODIFY(_Str, _Old_size, _New_size) (_Str)._Modify_annotation(_Old_size, _New_size)
    // DEBUG: #else // ^^^ _INSERT_STRING_ANNOTATION / !_INSERT_STRING_ANNOTATION vvv
    // DEBUG: #define _ASAN_STRING_REMOVE(_Str)
    // DEBUG: #define _ASAN_STRING_CREATE(_Str)
    // DEBUG: #define _ASAN_STRING_MODIFY(_Str, _Old_size, _New_size)
    // DEBUG: #endif // ^^^ !_INSERT_STRING_ANNOTATION ^^^
    // DEBUG: 
    // DEBUG: public:
    // DEBUG:     _CONSTEXPR20
    // DEBUG:     basic_string() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {
    // DEBUG:         _Construct_empty();
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _CONSTEXPR20 explicit basic_string(const _Alloc& _Al) noexcept : _Mypair(_One_then_variadic_args_t{}, _Al) {
    // DEBUG:         _Construct_empty();
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _CONSTEXPR20 basic_string(const basic_string& _Right)
    // DEBUG:         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {
    // DEBUG:         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _CONSTEXPR20 basic_string(const basic_string& _Right, const _Alloc& _Al)
    // DEBUG:         : _Mypair(_One_then_variadic_args_t{}, _Al) {
    // DEBUG:         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _CONSTEXPR20 basic_string(const basic_string& _Right, const size_type _Roff, const _Alloc& _Al = _Alloc())
    // DEBUG:         : _Mypair(_One_then_variadic_args_t{}, _Al) { // construct from _Right [_Roff, <end>)
    // DEBUG:         _Right._Mypair._Myval2._Check_offset(_Roff);
    // DEBUG:         _Construct<_Construct_strategy::_From_ptr>(
    // DEBUG:             _Right._Mypair._Myval2._Myptr() + _Roff, _Right._Mypair._Myval2._Clamp_suffix_size(_Roff, npos));
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _CONSTEXPR20 basic_string(
    // DEBUG:         const basic_string& _Right, const size_type _Roff, const size_type _Count, const _Alloc& _Al = _Alloc())
    // DEBUG:         : _Mypair(_One_then_variadic_args_t{}, _Al) { // construct from _Right [_Roff, _Roff + _Count)
    // DEBUG:         _Right._Mypair._Myval2._Check_offset(_Roff);
    // DEBUG:         _Construct<_Construct_strategy::_From_ptr>(
    // DEBUG:             _Right._Mypair._Myval2._Myptr() + _Roff, _Right._Mypair._Myval2._Clamp_suffix_size(_Roff, _Count));
    // DEBUG:     }
    // DEBUG: 
    // DEBUG: #if _HAS_CXX23
    // DEBUG:     constexpr basic_string(basic_string&& _Right, const size_type _Roff, const _Alloc& _Al = _Alloc())
    // DEBUG:         : _Mypair(_One_then_variadic_args_t{}, _Al) { // construct from _Right [_Roff, <end>), potentially move
    // DEBUG:         _Move_construct_from_substr(_Right, _Roff, npos);
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     constexpr basic_string(
    // DEBUG:         basic_string&& _Right, const size_type _Roff, const size_type _Count, const _Alloc& _Al = _Alloc())
    // DEBUG:         : _Mypair(_One_then_variadic_args_t{}, _Al) { // construct from _Right [_Roff, _Roff + _Count), potentially move
    // DEBUG:         _Move_construct_from_substr(_Right, _Roff, _Count);
    // DEBUG:     }
    // DEBUG: #endif // _HAS_CXX23
    // DEBUG: 
    // DEBUG:     _CONSTEXPR20 basic_string(_In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count)
    // DEBUG:         : _Mypair(_Zero_then_variadic_args_t{}) {
    // DEBUG:         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Count);
    // DEBUG:     }
    // DEBUG: 
    // DEBUG: #if _HAS_CXX17
    // DEBUG:     template <class _Alloc2 = _Alloc, enable_if_t<_Is_allocator<_Alloc2>::value, int> = 0>
    // DEBUG: #endif // _HAS_CXX17
    // DEBUG:     _CONSTEXPR20 basic_string(
    // DEBUG:         _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count, const _Alloc& _Al)
    // DEBUG:         : _Mypair(_One_then_variadic_args_t{}, _Al) {
    // DEBUG:         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Count);
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _CONSTEXPR20 basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t{}) {
    // DEBUG:         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));
    // DEBUG:     }
    // DEBUG: 
    // DEBUG: #if _HAS_CXX17
    // DEBUG:     template <class _Alloc2 = _Alloc, enable_if_t<_Is_allocator<_Alloc2>::value, int> = 0>
    // DEBUG: #endif // _HAS_CXX17
    // DEBUG:     _CONSTEXPR20 basic_string(_In_z_ const _Elem* const _Ptr, const _Alloc& _Al)
    // DEBUG:         : _Mypair(_One_then_variadic_args_t{}, _Al) {
    // DEBUG:         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));
    // DEBUG:     }
    // DEBUG: 
    // DEBUG: #if _HAS_CXX23
    // DEBUG:     basic_string(nullptr_t) = delete;
    // DEBUG: #endif // _HAS_CXX23
    // DEBUG: 
    // DEBUG:     _CONSTEXPR20 basic_string(_CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch)
    // DEBUG:         : _Mypair(_Zero_then_variadic_args_t{}) { // construct from _Count * _Ch
    // DEBUG:         _Construct<_Construct_strategy::_From_char>(_Ch, _Count);
    // DEBUG:     }
    // DEBUG: 
    // DEBUG: #if _HAS_CXX17
    // DEBUG:     template <class _Alloc2 = _Alloc, enable_if_t<_Is_allocator<_Alloc2>::value, int> = 0>
    // DEBUG: #endif // _HAS_CXX17
    // DEBUG:     _CONSTEXPR20 basic_string(_CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch, const _Alloc& _Al)
    // DEBUG:         : _Mypair(_One_then_variadic_args_t{}, _Al) { // construct from _Count * _Ch with allocator
    // DEBUG:         _Construct<_Construct_strategy::_From_char>(_Ch, _Count);
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
    // DEBUG:     _CONSTEXPR20 basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al = _Alloc())
    // DEBUG:         : _Mypair(_One_then_variadic_args_t{}, _Al) {
    // DEBUG:         _STD _Adl_verify_range(_First, _Last);
    // DEBUG:         auto _UFirst = _STD _Get_unwrapped(_First);
    // DEBUG:         auto _ULast  = _STD _Get_unwrapped(_Last);
    // DEBUG:         if (_UFirst == _ULast) {
    // DEBUG:             _Construct_empty();
    // DEBUG:         } else {
    // DEBUG:             if constexpr (_Is_elem_cptr<decltype(_UFirst)>::value) {
    // DEBUG:                 _Construct<_Construct_strategy::_From_ptr>(
    // DEBUG:                     _UFirst, _STD _Convert_size<size_type>(static_cast<size_t>(_ULast - _UFirst)));
    // DEBUG:             } else if constexpr (_Is_cpp17_fwd_iter_v<decltype(_UFirst)>) {
    // DEBUG:                 const auto _Length = static_cast<size_t>(_STD distance(_UFirst, _ULast));
    // DEBUG:                 const auto _Count  = _STD _Convert_size<size_type>(_Length);
    // DEBUG:                 _Construct_from_iter(_STD move(_UFirst), _STD move(_ULast), _Count);
    // DEBUG:             } else {
    // DEBUG:                 _Construct_from_iter(_STD move(_UFirst), _STD move(_ULast));
    // DEBUG:             }
    // DEBUG:         }
    // DEBUG:     }
    // DEBUG: 
    // DEBUG: private:
    // DEBUG:     enum class _Allocation_policy { _At_least, _Exactly };
    // DEBUG: 
    // DEBUG:     template <_Allocation_policy _Policy = _Allocation_policy::_At_least>
    // DEBUG:     _NODISCARD static _CONSTEXPR20 pointer _Allocate_for_capacity(_Alty& _Al, size_type& _Capacity) {
    // DEBUG:         _STL_INTERNAL_CHECK(_Capacity > _Small_string_capacity);
    // DEBUG:         ++_Capacity; // Take null terminator into consideration
    // DEBUG: 
    // DEBUG:         pointer _Fancy_ptr = nullptr;
    // DEBUG:         if constexpr (_Policy == _Allocation_policy::_At_least) {
    // DEBUG:             _Fancy_ptr = _Allocate_at_least_helper(_Al, _Capacity);
    // DEBUG:         } else {
    // DEBUG:             _STL_INTERNAL_STATIC_ASSERT(_Policy == _Allocation_policy::_Exactly);
    // DEBUG:             _Fancy_ptr = _Al.allocate(_Capacity);
    // DEBUG:         }
    // DEBUG: 
    // DEBUG: #if _HAS_CXX20
    // DEBUG:         // Start element lifetimes to avoid UB. This is a more general mechanism than _String_val::_Activate_SSO_buffer,
    // DEBUG:         // but likely more impactful to throughput.
    // DEBUG:         if (_STD is_constant_evaluated()) {
    // DEBUG:             _Elem* const _Ptr = _Unfancy(_Fancy_ptr);
    // DEBUG:             for (size_type _Idx = 0; _Idx < _Capacity; ++_Idx) {
    // DEBUG:                 _STD construct_at(_Ptr + _Idx);
    // DEBUG:             }
    // DEBUG:         }
    // DEBUG: #endif // _HAS_CXX20
    // DEBUG:         --_Capacity;
    // DEBUG:         return _Fancy_ptr;
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     static _CONSTEXPR20 void _Deallocate_for_capacity(
    // DEBUG:         _Alty& _Al, const pointer _Old_ptr, const size_type _Capacity) noexcept {
    // DEBUG:         _STL_INTERNAL_CHECK(_Capacity > _Small_string_capacity);
    // DEBUG:         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _CONSTEXPR20 void _Construct_empty() {
    // DEBUG:         auto& _My_data = _Mypair._Myval2;
    // DEBUG:         _My_data._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
    // DEBUG: 
    // DEBUG:         // initialize basic_string data members
    // DEBUG:         _My_data._Mysize = 0;
    // DEBUG:         _My_data._Myres  = _Small_string_capacity;
    // DEBUG:         _My_data._Activate_SSO_buffer();
    // DEBUG: 
    // DEBUG:         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
    // DEBUG:         _Traits::assign(_My_data._Bx._Buf[0], _Elem());
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     enum class _Construct_strategy : uint8_t { _From_char, _From_ptr, _From_string };
    // DEBUG: 
    // DEBUG:     template <_Construct_strategy _Strat, class _Char_or_ptr>
    // DEBUG:     _CONSTEXPR20 void _Construct(const _Char_or_ptr _Arg, _CRT_GUARDOVERFLOW const size_type _Count) {
    // DEBUG:         auto& _My_data = _Mypair._Myval2;
    // DEBUG:         _STL_INTERNAL_CHECK(!_My_data._Large_mode_engaged());
    // DEBUG: 
    // DEBUG:         if constexpr (_Strat == _Construct_strategy::_From_char) {
    // DEBUG:             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Char_or_ptr, _Elem>);
    // DEBUG:         } else {
    // DEBUG:             _STL_INTERNAL_STATIC_ASSERT(_Is_elem_cptr<_Char_or_ptr>::value);
    // DEBUG:         }
    // DEBUG: 
    // DEBUG:         if (_Count > max_size()) {
    // DEBUG:             _Xlen_string(); // result too long
    // DEBUG:         }
    // DEBUG: 
    // DEBUG:         auto& _Al       = _Getal();
    // DEBUG:         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
    // DEBUG:         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
    // DEBUG: 
    // DEBUG:         if (_Count <= _Small_string_capacity) {
    // DEBUG:             _My_data._Mysize = _Count;
    // DEBUG:             _My_data._Myres  = _Small_string_capacity;
    // DEBUG: 
    // DEBUG:             if constexpr (_Strat == _Construct_strategy::_From_char) {
    // DEBUG:                 _Traits::assign(_My_data._Bx._Buf, _Count, _Arg);
    // DEBUG:                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());
    // DEBUG:             } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
    // DEBUG:                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count);
    // DEBUG:                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());
    // DEBUG:             } else { // _Strat == _Construct_strategy::_From_string
    // DEBUG: #ifdef _INSERT_STRING_ANNOTATION
    // DEBUG:                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count + 1);
    // DEBUG: #else // ^^^ _INSERT_STRING_ANNOTATION / !_INSERT_STRING_ANNOTATION vvv
    // DEBUG:                 _Traits::copy(_My_data._Bx._Buf, _Arg, _BUF_SIZE);
    // DEBUG: #endif // ^^^ !_INSERT_STRING_ANNOTATION ^^^
    // DEBUG:             }
    // DEBUG: 
    // DEBUG:             _Proxy._Release();
    // DEBUG:             return;
    // DEBUG:         }
    // DEBUG: 
    // DEBUG:         size_type _New_capacity = _Calculate_growth(_Count, _Small_string_capacity, max_size());
    // DEBUG:         const pointer _New_ptr  = _Allocate_for_capacity(_Al, _New_capacity); // throws
    // DEBUG:         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);
    // DEBUG: 
    // DEBUG:         _My_data._Mysize = _Count;
    // DEBUG:         _My_data._Myres  = _New_capacity;
    // DEBUG:         if constexpr (_Strat == _Construct_strategy::_From_char) {
    // DEBUG:             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
    // DEBUG:             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
    // DEBUG:         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
    // DEBUG:             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
    // DEBUG:             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
    // DEBUG:         } else { // _Strat == _Construct_strategy::_From_string
    // DEBUG:             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);
    // DEBUG:         }
    // DEBUG: 
    // DEBUG:         _ASAN_STRING_CREATE(*this);
    // DEBUG:         _Proxy._Release();
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     template <class _Iter, class _Sent, class _Size = nullptr_t>
    // DEBUG:     _CONSTEXPR20 void _Construct_from_iter(_Iter _First, const _Sent _Last, _Size _Count = {}) {
    // DEBUG:         // Pre: _Iter models input_iterator or meets the Cpp17InputIterator requirements.
    // DEBUG:         // Pre: [_First, _Last) is a valid range.
    // DEBUG:         // Pre: if _Iter models forward_iterator or meets the Cpp17ForwardIterator requirements,
    // DEBUG:         //      then is_same_v<_Size, size_type> holds.
    // DEBUG:         // Pre: if is_same_v<_Size, size_type>, _Count is the length of [_First, _Last).
    // DEBUG:         // Pre: *this is in small mode; the lifetime of the SSO elements has already begun.
    // DEBUG: 
    // DEBUG:         auto& _My_data  = _Mypair._Myval2;
    // DEBUG:         auto& _Al       = _Getal();
    // DEBUG:         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
    // DEBUG:         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
    // DEBUG: 
    // DEBUG:         _My_data._Mysize = 0;
    // DEBUG:         _My_data._Myres  = _Small_string_capacity;
    // DEBUG: 
    // DEBUG:         if constexpr (is_same_v<_Size, size_type>) {
    // DEBUG:             if (_Count > max_size()) {
    // DEBUG:                 _Xlen_string(); // result too long
    // DEBUG:             }
    // DEBUG: 
    // DEBUG:             if (_Count > _Small_string_capacity) {
    // DEBUG:                 size_type _New_capacity = _Calculate_growth(_Count);
    // DEBUG:                 const pointer _New_ptr  = _Allocate_for_capacity(_Al, _New_capacity); // throws
    // DEBUG:                 _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);
    // DEBUG:                 _My_data._Myres = _New_capacity;
    // DEBUG:             }
    // DEBUG:         }
    // DEBUG: 
    // DEBUG:         _Tidy_deallocate_guard<basic_string> _Guard{this};
    // DEBUG: 
    // DEBUG:         constexpr bool _Can_construct_by_copy =
    // DEBUG:             _Is_specialization_v<_Traits, char_traits> && _Is_EcharT<_Elem> && is_same_v<_Size, size_type>;
    // DEBUG: 
    // DEBUG:         if constexpr (_Can_construct_by_copy) {
    // DEBUG:             const auto _Data = _My_data._Myptr();
    // DEBUG:             _STD _Copy_n_unchecked4(_STD move(_First), _Count, _Data);
    // DEBUG:             _My_data._Mysize = _Count;
    // DEBUG:             _Data[_Count]    = _Elem();
    // DEBUG:         } else {
    // DEBUG:             for (; _First != _Last; ++_First) {
    // DEBUG:                 if constexpr (!is_same_v<_Size, size_type>) {
    // DEBUG:                     if (_My_data._Mysize == _My_data._Myres) { // Need to grow
    // DEBUG:                         if (_My_data._Mysize == max_size()) {
    // DEBUG:                             _Xlen_string(); // result too long
    // DEBUG:                         }
    // DEBUG: 
    // DEBUG:                         _Elem* const _Old_ptr   = _My_data._Myptr();
    // DEBUG:                         size_type _New_capacity = _Calculate_growth(_My_data._Mysize + 1);
    // DEBUG:                         const pointer _New_ptr  = _Allocate_for_capacity(_Al, _New_capacity); // throws
    // DEBUG: 
    // DEBUG:                         _Traits::copy(_Unfancy(_New_ptr), _Old_ptr, _My_data._Mysize);
    // DEBUG:                         if (_My_data._Large_mode_engaged()) { // Need to deallocate old storage
    // DEBUG:                             _Deallocate_for_capacity(_Al, _My_data._Bx._Ptr, _My_data._Myres);
    // DEBUG:                             _My_data._Bx._Ptr = _New_ptr;
    // DEBUG:                         } else {
    // DEBUG:                             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);
    // DEBUG:                         }
    // DEBUG:                         _My_data._Myres = _New_capacity;
    // DEBUG:                     }
    // DEBUG:                 }
    // DEBUG: 
    // DEBUG:                 _Elem* const _Ptr = _My_data._Myptr();
    // DEBUG:                 _Traits::assign(_Ptr[_My_data._Mysize], *_First);
    // DEBUG:                 ++_My_data._Mysize;
    // DEBUG:             }
    // DEBUG: 
    // DEBUG:             _Elem* const _Ptr = _My_data._Myptr();
    // DEBUG:             _Traits::assign(_Ptr[_My_data._Mysize], _Elem());
    // DEBUG:         }
    // DEBUG: 
    // DEBUG:         _ASAN_STRING_CREATE(*this);
    // DEBUG:         _Guard._Target = nullptr;
    // DEBUG:         _Proxy._Release();
    // DEBUG:     }
    // DEBUG: 
    // DEBUG: public:
    // DEBUG: #if _HAS_CXX23
    // DEBUG:     template <_Container_compatible_range<_Elem> _Rng>
    // DEBUG:     constexpr basic_string(from_range_t, _Rng&& _Range, const _Alloc& _Al = _Alloc())
    // DEBUG:         : _Mypair(_One_then_variadic_args_t{}, _Al) {
    // DEBUG:         if constexpr (_RANGES sized_range<_Rng> || _RANGES forward_range<_Rng>) {
    // DEBUG:             const auto _Length = _To_unsigned_like(_RANGES distance(_Range));
    // DEBUG:             const auto _Count  = _Convert_size<size_type>(_Length);
    // DEBUG:             if constexpr (_Contiguous_range_of<_Rng, _Elem>) {
    // DEBUG:                 _Construct<_Construct_strategy::_From_ptr>(_RANGES data(_Range), _Count);
    // DEBUG:             } else {
    // DEBUG:                 _Construct_from_iter(_RANGES _Ubegin(_Range), _RANGES _Uend(_Range), _Count);
    // DEBUG:             }
    // DEBUG:         } else {
    // DEBUG:             _Construct_from_iter(_RANGES _Ubegin(_Range), _RANGES _Uend(_Range));
    // DEBUG:         }
    // DEBUG:     }
    // DEBUG: #endif // _HAS_CXX23
    // DEBUG: 
    // DEBUG:     _CONSTEXPR20 basic_string(basic_string&& _Right) noexcept
    // DEBUG:         : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal())) {
    // DEBUG:         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
    // DEBUG:         _Take_contents(_Right);
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _CONSTEXPR20 basic_string(basic_string&& _Right, const _Alloc& _Al)
    // DEBUG:         noexcept(_Alty_traits::is_always_equal::value) // strengthened
    // DEBUG:         : _Mypair(_One_then_variadic_args_t{}, _Al) {
    // DEBUG:         if constexpr (!_Alty_traits::is_always_equal::value) {
    // DEBUG:             if (_Getal() != _Right._Getal()) {
    // DEBUG:                 _Construct<_Construct_strategy::_From_string>(
    // DEBUG:                     _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
    // DEBUG:                 return;
    // DEBUG:             }
    // DEBUG:         }
    // DEBUG: 
    // DEBUG:         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
    // DEBUG:         _Take_contents(_Right);
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _CONSTEXPR20 basic_string(_String_constructor_concat_tag, const basic_string& _Source_of_al,
    // DEBUG:         const _Elem* const _Left_ptr, const size_type _Left_size, const _Elem* const _Right_ptr,
    // DEBUG:         const size_type _Right_size)
    // DEBUG:         : _Mypair(_One_then_variadic_args_t{},
    // DEBUG:               _Alty_traits::select_on_container_copy_construction(_Source_of_al._Getal())) {
    // DEBUG:         _STL_INTERNAL_CHECK(_Left_size <= max_size());
    // DEBUG:         _STL_INTERNAL_CHECK(_Right_size <= max_size());
    // DEBUG:         _STL_INTERNAL_CHECK(_Right_size <= max_size() - _Left_size);
    // DEBUG:         const auto _New_size    = static_cast<size_type>(_Left_size + _Right_size);
    // DEBUG:         size_type _New_capacity = _Small_string_capacity;
    // DEBUG:         auto& _My_data          = _Mypair._Myval2;
    // DEBUG:         _Elem* _Ptr             = _My_data._Bx._Buf;
    // DEBUG:         auto&& _Alproxy         = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
    // DEBUG:         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data); // throws
    // DEBUG: 
    // DEBUG:         if (_New_capacity < _New_size) {
    // DEBUG:             _New_capacity           = _Calculate_growth(_New_size, _Small_string_capacity, max_size());
    // DEBUG:             const pointer _Fancyptr = _Allocate_for_capacity(_Getal(), _New_capacity); // throws
    // DEBUG:             _Ptr                    = _Unfancy(_Fancyptr);
    // DEBUG:             _Construct_in_place(_My_data._Bx._Ptr, _Fancyptr);
    // DEBUG:         }
    // DEBUG: 
    // DEBUG:         _My_data._Mysize = _New_size;
    // DEBUG:         _My_data._Myres  = _New_capacity;
    // DEBUG:         _Traits::copy(_Ptr, _Left_ptr, _Left_size);
    // DEBUG:         _Traits::copy(_Ptr + static_cast<ptrdiff_t>(_Left_size), _Right_ptr, _Right_size);
    // DEBUG:         _Traits::assign(_Ptr[_New_size], _Elem());
    // DEBUG:         _ASAN_STRING_CREATE(*this);
    // DEBUG:         _Proxy._Release();
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _CONSTEXPR20 basic_string(_String_constructor_concat_tag, basic_string& _Left, basic_string& _Right)
    // DEBUG:         : _Mypair(_One_then_variadic_args_t{}, _Left._Getal()) {
    // DEBUG:         auto& _My_data    = _Mypair._Myval2;
    // DEBUG:         auto& _Left_data  = _Left._Mypair._Myval2;
    // DEBUG:         auto& _Right_data = _Right._Mypair._Myval2;
    // DEBUG:         _Left_data._Orphan_all();
    // DEBUG:         _Right_data._Orphan_all();
    // DEBUG:         const auto _Left_size  = _Left_data._Mysize;
    // DEBUG:         const auto _Right_size = _Right_data._Mysize;
    // DEBUG: 
    // DEBUG:         const auto _Left_capacity  = _Left_data._Myres;
    // DEBUG:         const auto _Right_capacity = _Right_data._Myres;
    // DEBUG:         // overflow is OK due to max_size() checks:
    // DEBUG:         const auto _New_size     = static_cast<size_type>(_Left_size + _Right_size);
    // DEBUG:         const bool _Fits_in_left = _Right_size <= _Left_capacity - _Left_size;
    // DEBUG:         if (_Fits_in_left && _Right_capacity <= _Left_capacity) {
    // DEBUG:             // take _Left's buffer, max_size() is OK because _Fits_in_left
    // DEBUG:             _My_data._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal())); // throws, hereafter nothrow in this block
    // DEBUG:             _Take_contents(_Left);
    // DEBUG:             const auto _Ptr = _My_data._Myptr();
    // DEBUG:             _ASAN_STRING_MODIFY(*this, _Left_size, _New_size);
    // DEBUG:             _Traits::copy(_Ptr + _Left_size, _Right_data._Myptr(), _Right_size + 1);
    // DEBUG:             _My_data._Mysize = _New_size;
    // DEBUG:             return;
    // DEBUG:         }
    // DEBUG: 
    // DEBUG:         const bool _Fits_in_right = _Left_size <= _Right_capacity - _Right_size;
    // DEBUG:         if (_Allocators_equal(_Getal(), _Right._Getal()) && _Fits_in_right) {
    // DEBUG:             // take _Right's buffer, max_size() is OK because _Fits_in_right
    // DEBUG:             // At this point, we have tested:
    // DEBUG:             // !(_Fits_in_left && _Right_capacity <= _Left_capacity) && _Fits_in_right
    // DEBUG:             // therefore: (by De Morgan's Laws)
    // DEBUG:             // (!_Fits_in_left || _Right_capacity > _Left_capacity) && _Fits_in_right
    // DEBUG:             // therefore: (by the distributive property)
    // DEBUG:             // (!_Fits_in_left && _Fits_in_right)  // implying _Right has more capacity
    // DEBUG:             //     || (_Right_capacity > _Left_capacity && _Fits_in_right)  // tests that _Right has more capacity
    // DEBUG:             // therefore: _Right must have more than the minimum capacity, so it must be _Large_mode_engaged()
    // DEBUG:             _STL_INTERNAL_CHECK(_Right_data._Large_mode_engaged());
    // DEBUG:             _My_data._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal())); // throws, hereafter nothrow in this block
    // DEBUG:             _Take_contents(_Right);
    // DEBUG:             const auto _Ptr = _Unfancy(_My_data._Bx._Ptr);
    // DEBUG:             _ASAN_STRING_MODIFY(*this, _Right_size, _New_size);
    // DEBUG:             _Traits::move(_Ptr + _Left_size, _Ptr, _Right_size + 1);
    // DEBUG:             _Traits::copy(_Ptr, _Left_data._Myptr(), _Left_size);
    // DEBUG:             _My_data._Mysize = _New_size;
    // DEBUG:             return;
    // DEBUG:         }
    // DEBUG: 
    // DEBUG:         // can't use either buffer, reallocate
    // DEBUG:         const auto _Max = max_size();
    // DEBUG:         if (_Max - _Left_size < _Right_size) { // check if max_size() is OK
    // DEBUG:             _Xlen_string();
    // DEBUG:         }
    // DEBUG: 
    // DEBUG:         size_type _New_capacity = _Calculate_growth(_New_size, _Small_string_capacity, _Max);
    // DEBUG:         auto&& _Alproxy         = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
    // DEBUG:         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data); // throws
    // DEBUG:         const pointer _Fancyptr = _Allocate_for_capacity(_Getal(), _New_capacity); // throws
    // DEBUG:         // nothrow hereafter
    // DEBUG:         _Construct_in_place(_My_data._Bx._Ptr, _Fancyptr);
    // DEBUG:         _My_data._Mysize = _New_size;
    // DEBUG:         _My_data._Myres  = _New_capacity;
    // DEBUG:         const auto _Ptr  = _Unfancy(_Fancyptr);
    // DEBUG:         _Traits::copy(_Ptr, _Left_data._Myptr(), _Left_size);
    // DEBUG:         _Traits::copy(_Ptr + _Left_size, _Right_data._Myptr(), _Right_size + 1);
    // DEBUG:         _ASAN_STRING_CREATE(*this);
    // DEBUG:         _Proxy._Release();
    // DEBUG:     }
    // DEBUG: 
    // DEBUG: #if _HAS_CXX17
    // DEBUG:     template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
    // DEBUG:     _CONSTEXPR20 explicit basic_string(const _StringViewIsh& _Right, const _Alloc& _Al = _Alloc())
    // DEBUG:         : _Mypair(_One_then_variadic_args_t{}, _Al) {
    // DEBUG:         const basic_string_view<_Elem, _Traits> _As_view = _Right;
    // DEBUG:         _Construct<_Construct_strategy::_From_ptr>(_As_view.data(), _Convert_size<size_type>(_As_view.size()));
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     template <class _Ty, enable_if_t<is_convertible_v<const _Ty&, basic_string_view<_Elem, _Traits>>, int> = 0>
    // DEBUG:     _CONSTEXPR20 basic_string(
    // DEBUG:         const _Ty& _Right, const size_type _Roff, const size_type _Count, const _Alloc& _Al = _Alloc())
    // DEBUG:         : _Mypair(_One_then_variadic_args_t{}, _Al) { // construct from _Right [_Roff, _Roff + _Count) using _Al
    // DEBUG:         const basic_string_view<_Elem, _Traits> _As_view = _Right;
    // DEBUG:         const auto _As_sub_view                          = _As_view.substr(_Roff, _Count);
    // DEBUG:         _Construct<_Construct_strategy::_From_ptr>(_As_sub_view.data(), _Convert_size<size_type>(_As_sub_view.size()));
    // DEBUG:     }
    // DEBUG: #endif // _HAS_CXX17
    // DEBUG: 
    // DEBUG: #if _HAS_CXX20
    // DEBUG:     _NODISCARD bool _Move_assign_from_buffer(
    // DEBUG:         _Elem* const _Right, const size_type _Size, const size_type _Actual_allocation_size) {
    // DEBUG:         // Move assign from a buffer, used exclusively by basic_stringbuf; returns _Large_mode_engaged()
    // DEBUG:         auto& _My_data = _Mypair._Myval2;
    // DEBUG:         _STL_INTERNAL_CHECK(!_My_data._Large_mode_engaged() && _My_data._Mysize == 0);
    // DEBUG:         _STL_INTERNAL_CHECK(_Size < _Actual_allocation_size); // So there is room for null terminator
    // DEBUG:         _Traits::assign(_Right[_Size], _Elem());
    // DEBUG: 
    // DEBUG:         const bool _Is_large = _Actual_allocation_size >= _Least_allocation_size;
    // DEBUG:         if (_Is_large) {
    // DEBUG:             _ASAN_STRING_REMOVE(*this);
    // DEBUG:             _Construct_in_place(_My_data._Bx._Ptr, _Refancy<pointer>(_Right));
    // DEBUG:             _My_data._Mysize = _Size;
    // DEBUG:             _My_data._Myres  = _Actual_allocation_size - 1;
    // DEBUG:             _ASAN_STRING_CREATE(*this);
    // DEBUG:         } else {
    // DEBUG:             _Traits::copy(_My_data._Bx._Buf, _Right, _Actual_allocation_size);
    // DEBUG:             _My_data._Mysize = _Size;
    // DEBUG:             _My_data._Myres  = _Small_string_capacity;
    // DEBUG:         }
    // DEBUG: 
    // DEBUG:         return _Is_large;
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     // No instance of this type can exist where an exception may be thrown.
    // DEBUG:     struct _Released_buffer {
    // DEBUG:         pointer _Ptr;
    // DEBUG:         size_type _Size;
    // DEBUG:         size_type _Actual_allocation_size;
    // DEBUG:     };
    // DEBUG: 
    // DEBUG:     _NODISCARD _Released_buffer _Release_to_buffer(_Alloc& _Al) {
    // DEBUG:         // Release to a buffer, or allocate a new one if in small string mode; used exclusively by basic_stringbuf
    // DEBUG:         _Released_buffer _Result;
    // DEBUG:         auto& _My_data = _Mypair._Myval2;
    // DEBUG:         _Result._Size  = _My_data._Mysize;
    // DEBUG:         _My_data._Orphan_all();
    // DEBUG:         _ASAN_STRING_REMOVE(*this);
    // DEBUG:         if (_My_data._Large_mode_engaged()) {
    // DEBUG:             _Result._Ptr                    = _My_data._Bx._Ptr;
    // DEBUG:             _Result._Actual_allocation_size = _My_data._Myres + 1;
    // DEBUG: 
    // DEBUG:             _My_data._Bx._Switch_to_buf();
    // DEBUG:         } else {
    // DEBUG:             // use _Least_allocation_size to avoid small mode, if the buffer is assigned back
    // DEBUG:             size_type _Allocated = _Least_allocation_size;
    // DEBUG:             _Result._Ptr         = _Allocate_at_least_helper(_Al, _Allocated);
    // DEBUG:             _Traits::copy(_Unfancy(_Result._Ptr), _My_data._Bx._Buf, _BUF_SIZE);
    // DEBUG:             _Result._Actual_allocation_size = _Allocated;
    // DEBUG:         }
    // DEBUG:         _My_data._Mysize = 0;
    // DEBUG:         _My_data._Myres  = _Small_string_capacity;
    // DEBUG:         _Traits::assign(_My_data._Bx._Buf[0], _Elem());
    // DEBUG:         return _Result;
    // DEBUG:     }
    // DEBUG: #endif // _HAS_CXX20
    // DEBUG: 
    // DEBUG:     _CONSTEXPR20 basic_string& operator=(basic_string&& _Right)
    // DEBUG:         noexcept(_Choose_pocma_v<_Alty> != _Pocma_values::_No_propagate_allocators) {
    // DEBUG:         if (this == _STD addressof(_Right)) {
    // DEBUG:             return *this;
    // DEBUG:         }
    // DEBUG: 
    // DEBUG:         auto& _Al                 = _Getal();
    // DEBUG:         auto& _Right_al           = _Right._Getal();
    // DEBUG:         constexpr auto _Pocma_val = _Choose_pocma_v<_Alty>;
    // DEBUG:         if constexpr (_Pocma_val == _Pocma_values::_Propagate_allocators) {
    // DEBUG:             if (_Al != _Right_al) {
    // DEBUG:                 // intentionally slams into noexcept on OOM, TRANSITION, VSO-466800
    // DEBUG:                 _Mypair._Myval2._Orphan_all();
    // DEBUG:                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
    // DEBUG:             }
    // DEBUG:         } else if constexpr (_Pocma_val == _Pocma_values::_No_propagate_allocators) {
    // DEBUG:             if (_Al != _Right_al) {
    // DEBUG:                 assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
    // DEBUG:                 return *this;
    // DEBUG:             }
    // DEBUG:         }
    // DEBUG: 
    // DEBUG:         _Tidy_deallocate();
    // DEBUG:         _Pocma(_Al, _Right_al);
    // DEBUG:         _Take_contents(_Right);
    // DEBUG:         return *this;
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _CONSTEXPR20 basic_string& assign(basic_string&& _Right) noexcept(noexcept(*this = _STD move(_Right))) {
    // DEBUG:         *this = _STD move(_Right);
    // DEBUG:         return *this;
    // DEBUG:     }
    // DEBUG: 
    // DEBUG: private:
    // DEBUG:     _CONSTEXPR20 void _Take_contents(basic_string& _Right) noexcept {
    // DEBUG:         // assign by stealing _Right's buffer
    // DEBUG:         // pre: this != &_Right
    // DEBUG:         // pre: allocator propagation (POCMA) from _Right, if necessary, is complete
    // DEBUG:         // pre: *this owns no memory, iterators orphaned
    // DEBUG:         // (note: _Buf/_Ptr/_Mysize/_Myres may be garbage init)
    // DEBUG:         auto& _My_data    = _Mypair._Myval2;
    // DEBUG:         auto& _Right_data = _Right._Mypair._Myval2;
    // DEBUG: 
    // DEBUG: #if !defined(_INSERT_STRING_ANNOTATION)
    // DEBUG:         if constexpr (_Can_memcpy_val) {
    // DEBUG: #if _HAS_CXX20
    // DEBUG:             if (!_STD is_constant_evaluated())
    // DEBUG: #endif // _HAS_CXX20
    // DEBUG:             {
    // DEBUG: #if _ITERATOR_DEBUG_LEVEL != 0
    // DEBUG:                 if (_Right_data._Large_mode_engaged()) {
    // DEBUG:                     // take ownership of _Right's iterators along with its buffer
    // DEBUG:                     _Swap_proxy_and_iterators(_Right);
    // DEBUG:                 } else {
    // DEBUG:                     _Right_data._Orphan_all();
    // DEBUG:                 }
    // DEBUG: #endif // _ITERATOR_DEBUG_LEVEL != 0
    // DEBUG: 
    // DEBUG:                 const auto _My_data_mem =
    // DEBUG:                     reinterpret_cast<unsigned char*>(_STD addressof(_Mypair._Myval2)) + _Memcpy_val_offset;
    // DEBUG:                 const auto _Right_data_mem =
    // DEBUG:                     reinterpret_cast<const unsigned char*>(_STD addressof(_Right._Mypair._Myval2)) + _Memcpy_val_offset;
    // DEBUG:                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);
    // DEBUG: 
    // DEBUG:                 _Right_data._Mysize = 0;
    // DEBUG:                 _Right_data._Myres  = _Small_string_capacity;
    // DEBUG:                 _Right_data._Activate_SSO_buffer();
    // DEBUG:                 _Traits::assign(_Right_data._Bx._Buf[0], _Elem());
    // DEBUG:                 return;
    // DEBUG:             }
    // DEBUG:         }
    // DEBUG: #endif // !defined(_INSERT_STRING_ANNOTATION)
    // DEBUG: 
    // DEBUG:         if (_Right_data._Large_mode_engaged()) { // steal buffer
    // DEBUG:             _Swap_proxy_and_iterators(_Right);
    // DEBUG: 
    // DEBUG:             _Construct_in_place(_My_data._Bx._Ptr, _Right_data._Bx._Ptr);
    // DEBUG:             _Right_data._Bx._Switch_to_buf();
    // DEBUG:         } else { // copy small string buffer
    // DEBUG:             _Right_data._Orphan_all();
    // DEBUG: 
    // DEBUG:             _My_data._Activate_SSO_buffer();
    // DEBUG:             _Traits::copy(_My_data._Bx._Buf, _Right_data._Bx._Buf, _Right_data._Mysize + 1);
    // DEBUG:         }
    // DEBUG: 
    // DEBUG:         _My_data._Myres  = _Right_data._Myres;
    // DEBUG:         _My_data._Mysize = _Right_data._Mysize;
    // DEBUG: 
    // DEBUG:         _Right_data._Mysize = 0;
    // DEBUG:         _Right_data._Myres  = _Small_string_capacity;
    // DEBUG:         _Traits::assign(_Right_data._Bx._Buf[0], _Elem());
    // DEBUG:     }
    // DEBUG: 
    // DEBUG: #if _HAS_CXX23
    // DEBUG:     constexpr void _Move_construct_from_substr(basic_string& _Right, const size_type _Roff, const size_type _Size_max) {
    // DEBUG:         auto& _Right_data = _Right._Mypair._Myval2;
    // DEBUG:         _Right_data._Check_offset(_Roff);
    // DEBUG: 
    // DEBUG:         const auto _Result_size = _Right_data._Clamp_suffix_size(_Roff, _Size_max);
    // DEBUG:         const auto _Right_ptr   = _Right_data._Myptr();
    // DEBUG:         auto& _Al               = _Getal();
    // DEBUG:         if (_Allocators_equal(_Al, _Right._Getal()) && _Result_size > _Small_string_capacity) {
    // DEBUG:             _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al));
    // DEBUG: 
    // DEBUG:             if (_Roff != 0) {
    // DEBUG:                 _Traits::move(_Right_ptr, _Right_ptr + _Roff, _Result_size);
    // DEBUG:             }
    // DEBUG:             _Right._Eos(_Result_size);
    // DEBUG:             _Take_contents(_Right);
    // DEBUG:         } else {
    // DEBUG:             _Construct<_Construct_strategy::_From_ptr>(_Right_ptr + _Roff, _Result_size);
    // DEBUG:         }
    // DEBUG:     }
    // DEBUG: #endif // _HAS_CXX23
    // DEBUG: 
    // DEBUG: public:
    // DEBUG:     _CONSTEXPR20 basic_string(initializer_list<_Elem> _Ilist, const _Alloc& _Al = allocator_type())
    // DEBUG:         : _Mypair(_One_then_variadic_args_t{}, _Al) {
    // DEBUG:         _Construct<_Construct_strategy::_From_ptr>(_Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _CONSTEXPR20 basic_string& operator=(initializer_list<_Elem> _Ilist) {
    // DEBUG:         return assign(_Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _CONSTEXPR20 basic_string& operator+=(initializer_list<_Elem> _Ilist) {
    // DEBUG:         return append(_Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _CONSTEXPR20 basic_string& assign(initializer_list<_Elem> _Ilist) {
    // DEBUG:         return assign(_Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _CONSTEXPR20 basic_string& append(initializer_list<_Elem> _Ilist) {
    // DEBUG:         return append(_Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _CONSTEXPR20 iterator insert(const const_iterator _Where, const initializer_list<_Elem> _Ilist) {
    // DEBUG: #if _ITERATOR_DEBUG_LEVEL != 0
    // DEBUG:         _STL_VERIFY(_Where._Getcont() == _STD addressof(_Mypair._Myval2), "string iterator incompatible");
    // DEBUG: #endif // _ITERATOR_DEBUG_LEVEL != 0
    // DEBUG:         const auto _Off = static_cast<size_type>(_Unfancy(_Where._Ptr) - _Mypair._Myval2._Myptr());
    // DEBUG:         insert(_Off, _Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
    // DEBUG:         return begin() + static_cast<difference_type>(_Off);
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _CONSTEXPR20 basic_string& replace(
    // DEBUG:         const const_iterator _First, const const_iterator _Last, const initializer_list<_Elem> _Ilist) {
    // DEBUG:         // replace with initializer_list
    // DEBUG:         _STD _Adl_verify_range(_First, _Last);
    // DEBUG: #if _ITERATOR_DEBUG_LEVEL != 0
    // DEBUG:         _STL_VERIFY(_First._Getcont() == _STD addressof(_Mypair._Myval2), "string iterators incompatible");
    // DEBUG: #endif // _ITERATOR_DEBUG_LEVEL != 0
    // DEBUG:         const auto _Offset = static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr());
    // DEBUG:         const auto _Length = static_cast<size_type>(_Last._Ptr - _First._Ptr);
    // DEBUG:         return replace(_Offset, _Length, _Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _CONSTEXPR20 ~basic_string() noexcept {
    // DEBUG:         _Tidy_deallocate();
    // DEBUG: #if _ITERATOR_DEBUG_LEVEL != 0
    // DEBUG:         auto&& _Alproxy          = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
    // DEBUG:         const auto _To_delete    = _Mypair._Myval2._Myproxy;
    // DEBUG:         _Mypair._Myval2._Myproxy = nullptr;
    // DEBUG:         _Delete_plain_internal(_Alproxy, _To_delete);
    // DEBUG: #endif // _ITERATOR_DEBUG_LEVEL != 0
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     static constexpr auto npos{static_cast<size_type>(-1)};
    // DEBUG: 
    // DEBUG:     _CONSTEXPR20 basic_string& operator=(const basic_string& _Right) {
    // DEBUG:         if (this == _STD addressof(_Right)) {
    // DEBUG:             return *this;
    // DEBUG:         }
    // DEBUG: 
    // DEBUG:         auto& _Al             = _Getal();
    // DEBUG:         const auto& _Right_al = _Right._Getal();
    // DEBUG:         if constexpr (_Choose_pocca_v<_Alty>) {
    // DEBUG:             if (_Al != _Right_al) {
    // DEBUG:                 auto&& _Alproxy       = _GET_PROXY_ALLOCATOR(_Alty, _Al);
    // DEBUG:                 auto&& _Right_alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Right_al);
    // DEBUG:                 _Container_proxy_ptr<_Alty> _New_proxy(_Right_alproxy, _Leave_proxy_unbound{}); // throws
    // DEBUG: 
    // DEBUG:                 const size_type _Right_size   = _Right._Mypair._Myval2._Mysize;
    // DEBUG:                 const _Elem* const _Right_ptr = _Right._Mypair._Myval2._Myptr();
    // DEBUG:                 if (_Right_size > _Small_string_capacity) {
    // DEBUG:                     size_type _New_capacity = _Calculate_growth(_Right_size, _Small_string_capacity, _Right.max_size());
    // DEBUG:                     auto _Right_al_non_const = _Right_al;
    // DEBUG:                     const pointer _New_ptr   = _Allocate_for_capacity(_Right_al_non_const, _New_capacity); // throws
    // DEBUG:                     _Traits::copy(_Unfancy(_New_ptr), _Right_ptr, _Right_size + 1);
    // DEBUG: 
    // DEBUG:                     _Tidy_deallocate();
    // DEBUG:                     _Construct_in_place(_Mypair._Myval2._Bx._Ptr, _New_ptr);
    // DEBUG:                     _Mypair._Myval2._Mysize = _Right_size;
    // DEBUG:                     _Mypair._Myval2._Myres  = _New_capacity;
    // DEBUG:                     _ASAN_STRING_CREATE(*this);
    // DEBUG:                 } else {
    // DEBUG:                     _Tidy_deallocate();
    // DEBUG:                     _Traits::copy(_Mypair._Myval2._Bx._Buf, _Right_ptr, _Right_size + 1);
    // DEBUG:                     _Mypair._Myval2._Mysize = _Right_size;
    // DEBUG:                     _Mypair._Myval2._Myres  = _Small_string_capacity;
    // DEBUG:                 }
    // DEBUG: 
    // DEBUG:                 _Pocca(_Al, _Right_al);
    // DEBUG:                 _New_proxy._Bind(_Alproxy, _STD addressof(_Mypair._Myval2));
    // DEBUG:                 return *this;
    // DEBUG:             }
    // DEBUG:         }
    // DEBUG: 
    // DEBUG:         _Pocca(_Al, _Right_al);
    // DEBUG:         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
    // DEBUG:         return *this;
    // DEBUG:     }
    // DEBUG: 
    // DEBUG: #if _HAS_CXX17
    // DEBUG:     template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
    // DEBUG:     _CONSTEXPR20 basic_string& operator=(const _StringViewIsh& _Right) {
    // DEBUG:         return assign(_Right);
    // DEBUG:     }
    // DEBUG: #endif // _HAS_CXX17
    // DEBUG: 
    // DEBUG:     _CONSTEXPR20 basic_string& operator=(_In_z_ const _Elem* const _Ptr) {
    // DEBUG:         return assign(_Ptr);
    // DEBUG:     }
    // DEBUG: 
    // DEBUG: #if _HAS_CXX23
    // DEBUG:     basic_string& operator=(nullptr_t) = delete;
    // DEBUG: #endif // _HAS_CXX23
    // DEBUG: 
    // DEBUG:     _CONSTEXPR20 basic_string& operator=(const _Elem _Ch) { // assign {_Ch, _Elem()}
    // DEBUG:         _ASAN_STRING_MODIFY(*this, _Mypair._Myval2._Mysize, 1);
    // DEBUG:         _Mypair._Myval2._Mysize = 1;
    // DEBUG:         _Elem* const _Ptr       = _Mypair._Myval2._Myptr();
    // DEBUG:         _Traits::assign(_Ptr[0], _Ch);
    // DEBUG:         _Traits::assign(_Ptr[1], _Elem());
    // DEBUG:         return *this;
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _CONSTEXPR20 basic_string& operator+=(const basic_string& _Right) {
    // DEBUG:         return append(_Right);
    // DEBUG:     }
    // DEBUG: 
    // DEBUG: #if _HAS_CXX17
    // DEBUG:     template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
    // DEBUG:     _CONSTEXPR20 basic_string& operator+=(const _StringViewIsh& _Right) {
    // DEBUG:         return append(_Right);
    // DEBUG:     }
    // DEBUG: #endif // _HAS_CXX17
    // DEBUG: 
    // DEBUG:     _CONSTEXPR20 basic_string& operator+=(_In_z_ const _Elem* const _Ptr) { // append [_Ptr, <null>)
    // DEBUG:         return append(_Ptr);
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _CONSTEXPR20 basic_string& operator+=(_Elem _Ch) {
    // DEBUG:         push_back(_Ch);
    // DEBUG:         return *this;
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _CONSTEXPR20 basic_string& append(const basic_string& _Right) {
    // DEBUG:         return append(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _CONSTEXPR20 basic_string& append(const basic_string& _Right, const size_type _Roff, size_type _Count = npos) {
    // DEBUG:         // append _Right [_Roff, _Roff + _Count)
    // DEBUG:         _Right._Mypair._Myval2._Check_offset(_Roff);
    // DEBUG:         _Count = _Right._Mypair._Myval2._Clamp_suffix_size(_Roff, _Count);
    // DEBUG:         return append(_Right._Mypair._Myval2._Myptr() + _Roff, _Count);
    // DEBUG:     }
    // DEBUG: 
    // DEBUG: #if _HAS_CXX17
    // DEBUG:     template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
    // DEBUG:     _CONSTEXPR20 basic_string& append(const _StringViewIsh& _Right) {
    // DEBUG:         const basic_string_view<_Elem, _Traits> _As_view = _Right;
    // DEBUG:         return append(_As_view.data(), _Convert_size<size_type>(_As_view.size()));
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
    // DEBUG:     _CONSTEXPR20 basic_string& append(
    // DEBUG:         const _StringViewIsh& _Right, const size_type _Roff, const size_type _Count = npos) {
    // DEBUG:         // append _Right [_Roff, _Roff + _Count)
    // DEBUG:         basic_string_view<_Elem, _Traits> _As_view = _Right;
    // DEBUG:         return append(_As_view.substr(_Roff, _Count));
    // DEBUG:     }
    // DEBUG: #endif // _HAS_CXX17
    // DEBUG: 
    // DEBUG:     _CONSTEXPR20 basic_string& append(
    // DEBUG:         _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {
    // DEBUG:         // append [_Ptr, _Ptr + _Count)
    // DEBUG:         const size_type _Old_size = _Mypair._Myval2._Mysize;
    // DEBUG:         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {
    // DEBUG:             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
    // DEBUG:             _Mypair._Myval2._Mysize = _Old_size + _Count;
    // DEBUG:             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
    // DEBUG:             _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);
    // DEBUG:             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());
    // DEBUG:             return *this;
    // DEBUG:         }
    // DEBUG: 
    // DEBUG:         return _Reallocate_grow_by(
    // DEBUG:             _Count,
    // DEBUG:             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem* const _Ptr,
    // DEBUG:                 const size_type _Count) _STATIC_CALL_OPERATOR {
    // DEBUG:                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
    // DEBUG:                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);
    // DEBUG:                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
    // DEBUG:             },
    // DEBUG:             _Ptr, _Count);
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _CONSTEXPR20 basic_string& append(_In_z_ const _Elem* const _Ptr) { // append [_Ptr, <null>)
    // DEBUG:         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _CONSTEXPR20 basic_string& append(_CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch) {
    // DEBUG:         // append _Count * _Ch
    // DEBUG:         const size_type _Old_size = _Mypair._Myval2._Mysize;
    // DEBUG:         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {
    // DEBUG:             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
    // DEBUG:             _Mypair._Myval2._Mysize = _Old_size + _Count;
    // DEBUG:             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
    // DEBUG:             _Traits::assign(_Old_ptr + _Old_size, _Count, _Ch);
    // DEBUG:             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());
    // DEBUG:             return *this;
    // DEBUG:         }
    // DEBUG: 
    // DEBUG:         return _Reallocate_grow_by(
    // DEBUG:             _Count,
    // DEBUG:             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Count,
    // DEBUG:                 const _Elem _Ch) _STATIC_CALL_OPERATOR {
    // DEBUG:                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
    // DEBUG:                 _Traits::assign(_New_ptr + _Old_size, _Count, _Ch);
    // DEBUG:                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
    // DEBUG:             },
    // DEBUG:             _Count, _Ch);
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
    // DEBUG:     _CONSTEXPR20 basic_string& append(const _Iter _First, const _Iter _Last) {
    // DEBUG:         // append [_First, _Last), input iterators
    // DEBUG:         _STD _Adl_verify_range(_First, _Last);
    // DEBUG:         const auto _UFirst = _STD _Get_unwrapped(_First);
    // DEBUG:         const auto _ULast  = _STD _Get_unwrapped(_Last);
    // DEBUG:         if constexpr (_Is_elem_cptr<decltype(_UFirst)>::value) {
    // DEBUG:             return append(_UFirst, _STD _Convert_size<size_type>(static_cast<size_t>(_ULast - _UFirst)));
    // DEBUG:         } else {
    // DEBUG:             const basic_string _Right(_UFirst, _ULast, get_allocator());
    // DEBUG:             return append(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
    // DEBUG:         }
    // DEBUG:     }
    // DEBUG: 
    // DEBUG: #if _HAS_CXX23
    // DEBUG:     template <_Container_compatible_range<_Elem> _Rng>
    // DEBUG:     constexpr basic_string& append_range(_Rng&& _Range) {
    // DEBUG:         if constexpr (_RANGES sized_range<_Rng> && _Contiguous_range_of<_Rng, _Elem>) {
    // DEBUG:             const auto _Count = _Convert_size<size_type>(_To_unsigned_like(_RANGES size(_Range)));
    // DEBUG:             return append(_RANGES data(_Range), _Count);
    // DEBUG:         } else {
    // DEBUG:             const basic_string _Right(from_range, _Range, get_allocator());
    // DEBUG:             return append(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
    // DEBUG:         }
    // DEBUG:     }
    // DEBUG: #endif // _HAS_CXX23
    // DEBUG: 
    // DEBUG:     _CONSTEXPR20 basic_string& assign(const basic_string& _Right) {
    // DEBUG:         *this = _Right;
    // DEBUG:         return *this;
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _CONSTEXPR20 basic_string& assign(const basic_string& _Right, const size_type _Roff, size_type _Count = npos) {
    // DEBUG:         // assign _Right [_Roff, _Roff + _Count)
    // DEBUG:         _Right._Mypair._Myval2._Check_offset(_Roff);
    // DEBUG:         _Count = _Right._Mypair._Myval2._Clamp_suffix_size(_Roff, _Count);
    // DEBUG:         return assign(_Right._Mypair._Myval2._Myptr() + _Roff, _Count);
    // DEBUG:     }
    // DEBUG: 
    // DEBUG: #if _HAS_CXX17
    // DEBUG:     template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
    // DEBUG:     _CONSTEXPR20 basic_string& assign(const _StringViewIsh& _Right) {
    // DEBUG:         const basic_string_view<_Elem, _Traits> _As_view = _Right;
    // DEBUG:         return assign(_As_view.data(), _Convert_size<size_type>(_As_view.size()));
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
    // DEBUG:     _CONSTEXPR20 basic_string& assign(
    // DEBUG:         const _StringViewIsh& _Right, const size_type _Roff, const size_type _Count = npos) {
    // DEBUG:         // assign _Right [_Roff, _Roff + _Count)
    // DEBUG:         basic_string_view<_Elem, _Traits> _As_view = _Right;
    // DEBUG:         return assign(_As_view.substr(_Roff, _Count));
    // DEBUG:     }
    // DEBUG: #endif // _HAS_CXX17
    // DEBUG: 
    // DEBUG:     _CONSTEXPR20 basic_string& assign(
    // DEBUG:         _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {
    // DEBUG:         // assign [_Ptr, _Ptr + _Count)
    // DEBUG:         if (_Count <= _Mypair._Myval2._Myres) {
    // DEBUG:             _ASAN_STRING_REMOVE(*this);
    // DEBUG:             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
    // DEBUG:             _Mypair._Myval2._Mysize = _Count;
    // DEBUG:             _Traits::move(_Old_ptr, _Ptr, _Count);
    // DEBUG:             _Traits::assign(_Old_ptr[_Count], _Elem());
    // DEBUG:             _ASAN_STRING_CREATE(*this);
    // DEBUG:             return *this;
    // DEBUG:         }
    // DEBUG: 
    // DEBUG:         return _Reallocate_for(
    // DEBUG:             _Count,
    // DEBUG:             [](_Elem* const _New_ptr, const size_type _Count, const _Elem* const _Ptr) _STATIC_CALL_OPERATOR {
    // DEBUG:                 _Traits::copy(_New_ptr, _Ptr, _Count);
    // DEBUG:                 _Traits::assign(_New_ptr[_Count], _Elem());
    // DEBUG:             },
    // DEBUG:             _Ptr);
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _CONSTEXPR20 basic_string& assign(_In_z_ const _Elem* const _Ptr) {
    // DEBUG:         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _CONSTEXPR20 basic_string& assign(_CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch) {
    // DEBUG:         // assign _Count * _Ch
    // DEBUG:         if (_Count <= _Mypair._Myval2._Myres) {
    // DEBUG:             _ASAN_STRING_MODIFY(*this, _Mypair._Myval2._Mysize, _Count);
    // DEBUG:             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
    // DEBUG:             _Mypair._Myval2._Mysize = _Count;
    // DEBUG:             _Traits::assign(_Old_ptr, _Count, _Ch);
    // DEBUG:             _Traits::assign(_Old_ptr[_Count], _Elem());
    // DEBUG:             return *this;
    // DEBUG:         }
    // DEBUG: 
    // DEBUG:         return _Reallocate_for(
    // DEBUG:             _Count,
    // DEBUG:             [](_Elem* const _New_ptr, const size_type _Count, const _Elem _Ch) _STATIC_CALL_OPERATOR {
    // DEBUG:                 _Traits::assign(_New_ptr, _Count, _Ch);
    // DEBUG:                 _Traits::assign(_New_ptr[_Count], _Elem());
    // DEBUG:             },
    // DEBUG:             _Ch);
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
    // DEBUG:     _CONSTEXPR20 basic_string& assign(const _Iter _First, const _Iter _Last) {
    // DEBUG:         _STD _Adl_verify_range(_First, _Last);
    // DEBUG:         const auto _UFirst = _STD _Get_unwrapped(_First);
    // DEBUG:         const auto _ULast  = _STD _Get_unwrapped(_Last);
    // DEBUG:         if constexpr (_Is_elem_cptr<decltype(_UFirst)>::value) {
    // DEBUG:             return assign(_UFirst, _STD _Convert_size<size_type>(static_cast<size_t>(_ULast - _UFirst)));
    // DEBUG:         } else {
    // DEBUG:             basic_string _Right(_UFirst, _ULast, get_allocator());
    // DEBUG:             if (_Mypair._Myval2._Myres < _Right._Mypair._Myval2._Myres) {
    // DEBUG:                 _Mypair._Myval2._Orphan_all();
    // DEBUG:                 _Swap_data(_Right);
    // DEBUG:                 return *this;
    // DEBUG:             } else {
    // DEBUG:                 return assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
    // DEBUG:             }
    // DEBUG:         }
    // DEBUG:     }
    // DEBUG: 
    // DEBUG: #if _HAS_CXX23
    // DEBUG:     template <_Container_compatible_range<_Elem> _Rng>
    // DEBUG:     constexpr basic_string& assign_range(_Rng&& _Range) {
    // DEBUG:         if constexpr (_RANGES sized_range<_Rng> && _Contiguous_range_of<_Rng, _Elem>) {
    // DEBUG:             const auto _Count = _Convert_size<size_type>(_To_unsigned_like(_RANGES size(_Range)));
    // DEBUG:             return assign(_RANGES data(_Range), _Count);
    // DEBUG:         } else {
    // DEBUG:             basic_string _Right(from_range, _Range, get_allocator());
    // DEBUG:             if (_Mypair._Myval2._Myres < _Right._Mypair._Myval2._Myres) {
    // DEBUG:                 _Mypair._Myval2._Orphan_all();
    // DEBUG:                 _Swap_data(_Right);
    // DEBUG:                 return *this;
    // DEBUG:             } else {
    // DEBUG:                 return assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
    // DEBUG:             }
    // DEBUG:         }
    // DEBUG:     }
    // DEBUG: #endif // _HAS_CXX23
    // DEBUG: 
    // DEBUG:     _CONSTEXPR20 basic_string& insert(const size_type _Off, const basic_string& _Right) {
    // DEBUG:         // insert _Right at _Off
    // DEBUG:         return insert(_Off, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _CONSTEXPR20 basic_string& insert(
    // DEBUG:         const size_type _Off, const basic_string& _Right, const size_type _Roff, size_type _Count = npos) {
    // DEBUG:         // insert _Right [_Roff, _Roff + _Count) at _Off
    // DEBUG:         _Right._Mypair._Myval2._Check_offset(_Roff);
    // DEBUG:         _Count = _Right._Mypair._Myval2._Clamp_suffix_size(_Roff, _Count);
    // DEBUG:         return insert(_Off, _Right._Mypair._Myval2._Myptr() + _Roff, _Count);
    // DEBUG:     }
    // DEBUG: 
    // DEBUG: #if _HAS_CXX17
    // DEBUG:     template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
    // DEBUG:     _CONSTEXPR20 basic_string& insert(const size_type _Off, const _StringViewIsh& _Right) {
    // DEBUG:         // insert _Right at _Off
    // DEBUG:         const basic_string_view<_Elem, _Traits> _As_view = _Right;
    // DEBUG:         return insert(_Off, _As_view.data(), _Convert_size<size_type>(_As_view.size()));
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
    // DEBUG:     _CONSTEXPR20 basic_string& insert(
    // DEBUG:         const size_type _Off, const _StringViewIsh& _Right, const size_type _Roff, const size_type _Count = npos) {
    // DEBUG:         // insert _Right [_Roff, _Roff + _Count) at _Off
    // DEBUG:         basic_string_view<_Elem, _Traits> _As_view = _Right;
    // DEBUG:         return insert(_Off, _As_view.substr(_Roff, _Count));
    // DEBUG:     }
    // DEBUG: #endif // _HAS_CXX17
    // DEBUG: 
    // DEBUG:     _CONSTEXPR20 basic_string& insert(
    // DEBUG:         const size_type _Off, _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {
    // DEBUG:         // insert [_Ptr, _Ptr + _Count) at _Off
    // DEBUG:         _Mypair._Myval2._Check_offset(_Off);
    // DEBUG:         const size_type _Old_size = _Mypair._Myval2._Mysize;
    // DEBUG: 
    // DEBUG:         // We can't check for overlapping ranges when constant evaluated since comparison of pointers into string
    // DEBUG:         // literals is unspecified, so always reallocate and copy to the new buffer if constant evaluated.
    // DEBUG: #if _HAS_CXX20
    // DEBUG:         const bool _Check_overlap = _Count <= _Mypair._Myval2._Myres - _Old_size && !_STD is_constant_evaluated();
    // DEBUG: #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
    // DEBUG:         const bool _Check_overlap = _Count <= _Mypair._Myval2._Myres - _Old_size;
    // DEBUG: #endif // ^^^ !_HAS_CXX20 ^^^
    // DEBUG: 
    // DEBUG:         if (_Check_overlap) {
    // DEBUG:             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
    // DEBUG:             _Mypair._Myval2._Mysize = _Old_size + _Count;
    // DEBUG:             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
    // DEBUG:             _Elem* const _Insert_at = _Old_ptr + _Off;
    // DEBUG:             // the range [_Ptr, _Ptr + _Ptr_shifted_after) is left alone by moving the suffix out,
    // DEBUG:             // while the range [_Ptr + _Ptr_shifted_after, _Ptr + _Count) shifts down by _Count
    // DEBUG:             size_type _Ptr_shifted_after;
    // DEBUG:             if (_Ptr + _Count <= _Insert_at || _Ptr > _Old_ptr + _Old_size) {
    // DEBUG:                 // inserted content is before the shifted region, or does not alias
    // DEBUG:                 _Ptr_shifted_after = _Count; // none of _Ptr's data shifts
    // DEBUG:             } else if (_Insert_at <= _Ptr) { // all of [_Ptr, _Ptr + _Count) shifts
    // DEBUG:                 _Ptr_shifted_after = 0;
    // DEBUG:             } else { // [_Ptr, _Ptr + _Count) contains _Insert_at, so only the part after _Insert_at shifts
    // DEBUG:                 _Ptr_shifted_after = static_cast<size_type>(_Insert_at - _Ptr);
    // DEBUG:             }
    // DEBUG: 
    // DEBUG:             _Traits::move(_Insert_at + _Count, _Insert_at, _Old_size - _Off + 1); // move suffix + null down
    // DEBUG:             _Traits::copy(_Insert_at, _Ptr, _Ptr_shifted_after);
    // DEBUG:             _Traits::copy(
    // DEBUG:                 _Insert_at + _Ptr_shifted_after, _Ptr + _Count + _Ptr_shifted_after, _Count - _Ptr_shifted_after);
    // DEBUG:             return *this;
    // DEBUG:         }
    // DEBUG: 
    // DEBUG:         return _Reallocate_grow_by(
    // DEBUG:             _Count,
    // DEBUG:             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Off,
    // DEBUG:                 const _Elem* const _Ptr, const size_type _Count) _STATIC_CALL_OPERATOR {
    // DEBUG:                 _Traits::copy(_New_ptr, _Old_ptr, _Off);
    // DEBUG:                 _Traits::copy(_New_ptr + _Off, _Ptr, _Count);
    // DEBUG:                 _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);
    // DEBUG:             },
    // DEBUG:             _Off, _Ptr, _Count);
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _CONSTEXPR20 basic_string& insert(const size_type _Off, _In_z_ const _Elem* const _Ptr) {
    // DEBUG:         // insert [_Ptr, <null>) at _Off
    // DEBUG:         return insert(_Off, _Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _CONSTEXPR20 basic_string& insert(
    // DEBUG:         const size_type _Off, _CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch) {
    // DEBUG:         // insert _Count * _Ch at _Off
    // DEBUG:         _Mypair._Myval2._Check_offset(_Off);
    // DEBUG:         const size_type _Old_size = _Mypair._Myval2._Mysize;
    // DEBUG:         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {
    // DEBUG:             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
    // DEBUG:             _Mypair._Myval2._Mysize = _Old_size + _Count;
    // DEBUG:             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
    // DEBUG:             _Elem* const _Insert_at = _Old_ptr + _Off;
    // DEBUG:             _Traits::move(_Insert_at + _Count, _Insert_at, _Old_size - _Off + 1); // move suffix + null down
    // DEBUG:             _Traits::assign(_Insert_at, _Count, _Ch); // fill hole
    // DEBUG:             return *this;
    // DEBUG:         }
    // DEBUG: 
    // DEBUG:         return _Reallocate_grow_by(
    // DEBUG:             _Count,
    // DEBUG:             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Off,
    // DEBUG:                 const size_type _Count, const _Elem _Ch) _STATIC_CALL_OPERATOR {
    // DEBUG:                 _Traits::copy(_New_ptr, _Old_ptr, _Off);
    // DEBUG:                 _Traits::assign(_New_ptr + _Off, _Count, _Ch);
    // DEBUG:                 _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);
    // DEBUG:             },
    // DEBUG:             _Off, _Count, _Ch);
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _CONSTEXPR20 iterator insert(const const_iterator _Where, const _Elem _Ch) { // insert _Ch at _Where
    // DEBUG: #if _ITERATOR_DEBUG_LEVEL != 0
    // DEBUG:         _STL_VERIFY(_Where._Getcont() == _STD addressof(_Mypair._Myval2), "string iterator incompatible");
    // DEBUG: #endif // _ITERATOR_DEBUG_LEVEL != 0
    // DEBUG:         const auto _Off = static_cast<size_type>(_Unfancy(_Where._Ptr) - _Mypair._Myval2._Myptr());
    // DEBUG:         insert(_Off, 1, _Ch);
    // DEBUG:         return begin() + static_cast<difference_type>(_Off);
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _CONSTEXPR20 iterator insert(
    // DEBUG:         const const_iterator _Where, _CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch) {
    // DEBUG:         // insert _Count * _Elem at _Where
    // DEBUG: #if _ITERATOR_DEBUG_LEVEL != 0
    // DEBUG:         _STL_VERIFY(_Where._Getcont() == _STD addressof(_Mypair._Myval2), "string iterator incompatible");
    // DEBUG: #endif // _ITERATOR_DEBUG_LEVEL != 0
    // DEBUG:         const auto _Off = static_cast<size_type>(_Unfancy(_Where._Ptr) - _Mypair._Myval2._Myptr());
    // DEBUG:         insert(_Off, _Count, _Ch);
    // DEBUG:         return begin() + static_cast<difference_type>(_Off);
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
    // DEBUG:     _CONSTEXPR20 iterator insert(const const_iterator _Where, const _Iter _First, const _Iter _Last) {
    // DEBUG:         // insert [_First, _Last) at _Where, input iterators
    // DEBUG: #if _ITERATOR_DEBUG_LEVEL != 0
    // DEBUG:         _STL_VERIFY(_Where._Getcont() == _STD addressof(_Mypair._Myval2), "string iterator incompatible");
    // DEBUG: #endif // _ITERATOR_DEBUG_LEVEL != 0
    // DEBUG:         const auto _Off = static_cast<size_type>(_Unfancy(_Where._Ptr) - _Mypair._Myval2._Myptr());
    // DEBUG:         _STD _Adl_verify_range(_First, _Last);
    // DEBUG:         const auto _UFirst = _STD _Get_unwrapped(_First);
    // DEBUG:         const auto _ULast  = _STD _Get_unwrapped(_Last);
    // DEBUG:         if constexpr (_Is_elem_cptr<decltype(_UFirst)>::value) {
    // DEBUG:             insert(_Off, _UFirst, _STD _Convert_size<size_type>(static_cast<size_t>(_ULast - _UFirst)));
    // DEBUG:         } else {
    // DEBUG:             const basic_string _Right(_UFirst, _ULast, get_allocator());
    // DEBUG:             insert(_Off, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
    // DEBUG:         }
    // DEBUG: 
    // DEBUG:         return begin() + static_cast<difference_type>(_Off);
    // DEBUG:     }
    // DEBUG: 
    // DEBUG: #if _HAS_CXX23
    // DEBUG:     template <_Container_compatible_range<_Elem> _Rng>
    // DEBUG:     constexpr iterator insert_range(const const_iterator _Where, _Rng&& _Range) {
    // DEBUG: #if _ITERATOR_DEBUG_LEVEL != 0
    // DEBUG:         _STL_VERIFY(_Where._Getcont() == _STD addressof(_Mypair._Myval2), "string iterator incompatible");
    // DEBUG: #endif // _ITERATOR_DEBUG_LEVEL != 0
    // DEBUG:         const auto _Off = static_cast<size_type>(_Unfancy(_Where._Ptr) - _Mypair._Myval2._Myptr());
    // DEBUG: 
    // DEBUG:         if constexpr (_RANGES sized_range<_Rng> && _Contiguous_range_of<_Rng, _Elem>) {
    // DEBUG:             const auto _Count = _Convert_size<size_type>(_To_unsigned_like(_RANGES size(_Range)));
    // DEBUG:             insert(_Off, _RANGES data(_Range), _Count);
    // DEBUG:         } else {
    // DEBUG:             const basic_string _Right(from_range, _Range, get_allocator());
    // DEBUG:             insert(_Off, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
    // DEBUG:         }
    // DEBUG: 
    // DEBUG:         return begin() + static_cast<difference_type>(_Off);
    // DEBUG:     }
    // DEBUG: #endif // _HAS_CXX23
    // DEBUG: 
    // DEBUG:     _CONSTEXPR20 basic_string& erase(const size_type _Off = 0) { // erase elements [_Off, ...)
    // DEBUG:         _Mypair._Myval2._Check_offset(_Off);
    // DEBUG:         _Eos(_Off);
    // DEBUG:         return *this;
    // DEBUG:     }
    // DEBUG: 
    // DEBUG: private:
    // DEBUG:     _CONSTEXPR20 basic_string& _Erase_noexcept(const size_type _Off, size_type _Count) noexcept {
    // DEBUG:         _Count                    = _Mypair._Myval2._Clamp_suffix_size(_Off, _Count);
    // DEBUG:         const size_type _Old_size = _Mypair._Myval2._Mysize;
    // DEBUG:         _Elem* const _My_ptr      = _Mypair._Myval2._Myptr();
    // DEBUG:         _Elem* const _Erase_at    = _My_ptr + _Off;
    // DEBUG:         const size_type _New_size = _Old_size - _Count;
    // DEBUG:         _Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up
    // DEBUG:         _ASAN_STRING_MODIFY(*this, _Old_size, _New_size);
    // DEBUG:         _Mypair._Myval2._Mysize = _New_size;
    // DEBUG:         return *this;
    // DEBUG:     }
    // DEBUG: 
    // DEBUG: public:
    // DEBUG:     _CONSTEXPR20 basic_string& erase(const size_type _Off, const size_type _Count) {
    // DEBUG:         // erase elements [_Off, _Off + _Count)
    // DEBUG:         _Mypair._Myval2._Check_offset(_Off);
    // DEBUG:         return _Erase_noexcept(_Off, _Count);
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _CONSTEXPR20 iterator erase(const const_iterator _Where) noexcept /* strengthened */ {
    // DEBUG: #if _ITERATOR_DEBUG_LEVEL != 0
    // DEBUG:         _STL_VERIFY(_Where._Getcont() == _STD addressof(_Mypair._Myval2), "string iterator incompatible");
    // DEBUG: #endif // _ITERATOR_DEBUG_LEVEL != 0
    // DEBUG:         const auto _Off = static_cast<size_type>(_Unfancy(_Where._Ptr) - _Mypair._Myval2._Myptr());
    // DEBUG:         _Erase_noexcept(_Off, 1);
    // DEBUG:         return begin() + static_cast<difference_type>(_Off);
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _CONSTEXPR20 iterator erase(const const_iterator _First, const const_iterator _Last) noexcept
    // DEBUG:     /* strengthened */ {
    // DEBUG:         _STD _Adl_verify_range(_First, _Last);
    // DEBUG: #if _ITERATOR_DEBUG_LEVEL != 0
    // DEBUG:         _STL_VERIFY(_First._Getcont() == _STD addressof(_Mypair._Myval2), "string iterators incompatible");
    // DEBUG: #endif // _ITERATOR_DEBUG_LEVEL != 0
    // DEBUG:         const auto _Off = static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr());
    // DEBUG:         _Erase_noexcept(_Off, static_cast<size_type>(_Last._Ptr - _First._Ptr));
    // DEBUG:         return begin() + static_cast<difference_type>(_Off);
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _CONSTEXPR20 void clear() noexcept { // erase all
    // DEBUG:         _Eos(0);
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _CONSTEXPR20 basic_string& replace(const size_type _Off, const size_type _Nx, const basic_string& _Right) {
    // DEBUG:         // replace [_Off, _Off + _Nx) with _Right
    // DEBUG:         return replace(_Off, _Nx, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _CONSTEXPR20 basic_string& replace(const size_type _Off, size_type _Nx, const basic_string& _Right,
    // DEBUG:         const size_type _Roff, size_type _Count = npos) {
    // DEBUG:         // replace [_Off, _Off + _Nx) with _Right [_Roff, _Roff + _Count)
    // DEBUG:         _Right._Mypair._Myval2._Check_offset(_Roff);
    // DEBUG:         _Count = _Right._Mypair._Myval2._Clamp_suffix_size(_Roff, _Count);
    // DEBUG:         return replace(_Off, _Nx, _Right._Mypair._Myval2._Myptr() + _Roff, _Count);
    // DEBUG:     }
    // DEBUG: 
    // DEBUG: #if _HAS_CXX17
    // DEBUG:     template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
    // DEBUG:     _CONSTEXPR20 basic_string& replace(const size_type _Off, const size_type _Nx, const _StringViewIsh& _Right) {
    // DEBUG:         // replace [_Off, _Off + _Nx) with _Right
    // DEBUG:         basic_string_view<_Elem, _Traits> _As_view = _Right;
    // DEBUG:         return replace(_Off, _Nx, _As_view.data(), _Convert_size<size_type>(_As_view.size()));
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
    // DEBUG:     _CONSTEXPR20 basic_string& replace(const size_type _Off, const size_type _Nx, const _StringViewIsh& _Right,
    // DEBUG:         const size_type _Roff, const size_type _Count = npos) {
    // DEBUG:         // replace [_Off, _Off + _Nx) with _Right [_Roff, _Roff + _Count)
    // DEBUG:         basic_string_view<_Elem, _Traits> _As_view = _Right;
    // DEBUG:         return replace(_Off, _Nx, _As_view.substr(_Roff, _Count));
    // DEBUG:     }
    // DEBUG: #endif // _HAS_CXX17
    // DEBUG: 
    // DEBUG:     _CONSTEXPR20 basic_string& replace(
    // DEBUG:         const size_type _Off, size_type _Nx, _In_reads_(_Count) const _Elem* const _Ptr, const size_type _Count) {
    // DEBUG:         // replace [_Off, _Off + _Nx) with [_Ptr, _Ptr + _Count)
    // DEBUG:         _Mypair._Myval2._Check_offset(_Off);
    // DEBUG:         _Nx = _Mypair._Myval2._Clamp_suffix_size(_Off, _Nx);
    // DEBUG:         if (_Nx == _Count) { // size doesn't change, so a single move does the trick
    // DEBUG:             _Traits::move(_Mypair._Myval2._Myptr() + _Off, _Ptr, _Count);
    // DEBUG:             return *this;
    // DEBUG:         }
    // DEBUG: 
    // DEBUG:         const size_type _Old_size    = _Mypair._Myval2._Mysize;
    // DEBUG:         const size_type _Suffix_size = _Old_size - _Nx - _Off + 1;
    // DEBUG:         if (_Count < _Nx) { // suffix shifts backwards; we don't have to move anything out of the way
    // DEBUG:             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
    // DEBUG:             _Elem* const _Insert_at = _Old_ptr + _Off;
    // DEBUG:             _Traits::move(_Insert_at, _Ptr, _Count);
    // DEBUG:             _Traits::move(_Insert_at + _Count, _Insert_at + _Nx, _Suffix_size);
    // DEBUG: 
    // DEBUG:             const auto _New_size = _Old_size - (_Nx - _Count);
    // DEBUG:             _ASAN_STRING_MODIFY(*this, _Old_size, _New_size);
    // DEBUG:             _Mypair._Myval2._Mysize = _New_size;
    // DEBUG:             return *this;
    // DEBUG:         }
    // DEBUG: 
    // DEBUG:         const size_type _Growth = static_cast<size_type>(_Count - _Nx);
    // DEBUG: 
    // DEBUG:         // checking for overlapping ranges is technically UB (considering string literals), so just always reallocate
    // DEBUG:         // and copy to the new buffer if constant evaluated
    // DEBUG: #if _HAS_CXX20
    // DEBUG:         if (!_STD is_constant_evaluated())
    // DEBUG: #endif // _HAS_CXX20
    // DEBUG:         {
    // DEBUG:             if (_Growth <= _Mypair._Myval2._Myres - _Old_size) { // growth fits
    // DEBUG:                 _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Growth);
    // DEBUG:                 _Mypair._Myval2._Mysize = _Old_size + _Growth;
    // DEBUG:                 _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
    // DEBUG:                 _Elem* const _Insert_at = _Old_ptr + _Off;
    // DEBUG:                 _Elem* const _Suffix_at = _Insert_at + _Nx;
    // DEBUG: 
    // DEBUG:                 size_type _Ptr_shifted_after; // see rationale in insert
    // DEBUG:                 if (_Ptr + _Count <= _Insert_at || _Ptr > _Old_ptr + _Old_size) {
    // DEBUG:                     _Ptr_shifted_after = _Count;
    // DEBUG:                 } else if (_Suffix_at <= _Ptr) {
    // DEBUG:                     _Ptr_shifted_after = 0;
    // DEBUG:                 } else {
    // DEBUG:                     _Ptr_shifted_after = static_cast<size_type>(_Suffix_at - _Ptr);
    // DEBUG:                 }
    // DEBUG: 
    // DEBUG:                 _Traits::move(_Suffix_at + _Growth, _Suffix_at, _Suffix_size);
    // DEBUG:                 // next case must be move, in case _Ptr begins before _Insert_at and contains part of the hole;
    // DEBUG:                 // this case doesn't occur in insert because the new content must come from outside the removed
    // DEBUG:                 // content there (because in insert there is no removed content)
    // DEBUG:                 _Traits::move(_Insert_at, _Ptr, _Ptr_shifted_after);
    // DEBUG:                 // the next case can be copy, because it comes from the chunk moved out of the way in the
    // DEBUG:                 // first move, and the hole we're filling can't alias the chunk we moved out of the way
    // DEBUG:                 _Traits::copy(
    // DEBUG:                     _Insert_at + _Ptr_shifted_after, _Ptr + _Growth + _Ptr_shifted_after, _Count - _Ptr_shifted_after);
    // DEBUG:                 return *this;
    // DEBUG:             }
    // DEBUG:         }
    // DEBUG: 
    // DEBUG:         return _Reallocate_grow_by(
    // DEBUG:             _Growth,
    // DEBUG:             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Off,
    // DEBUG:                 const size_type _Nx, const _Elem* const _Ptr, const size_type _Count) _STATIC_CALL_OPERATOR {
    // DEBUG:                 _Traits::copy(_New_ptr, _Old_ptr, _Off);
    // DEBUG:                 _Traits::copy(_New_ptr + _Off, _Ptr, _Count);
    // DEBUG:                 _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off + _Nx, _Old_size - _Nx - _Off + 1);
    // DEBUG:             },
    // DEBUG:             _Off, _Nx, _Ptr, _Count);
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _CONSTEXPR20 basic_string& replace(const size_type _Off, const size_type _Nx, _In_z_ const _Elem* const _Ptr) {
    // DEBUG:         // replace [_Off, _Off + _Nx) with [_Ptr, <null>)
    // DEBUG:         return replace(_Off, _Nx, _Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _CONSTEXPR20 basic_string& replace(const size_type _Off, size_type _Nx, const size_type _Count, const _Elem _Ch) {
    // DEBUG:         // replace [_Off, _Off + _Nx) with _Count * _Ch
    // DEBUG:         _Mypair._Myval2._Check_offset(_Off);
    // DEBUG:         _Nx = _Mypair._Myval2._Clamp_suffix_size(_Off, _Nx);
    // DEBUG:         if (_Count == _Nx) {
    // DEBUG:             _Traits::assign(_Mypair._Myval2._Myptr() + _Off, _Count, _Ch);
    // DEBUG:             return *this;
    // DEBUG:         }
    // DEBUG: 
    // DEBUG:         const size_type _Old_size = _Mypair._Myval2._Mysize;
    // DEBUG:         if (_Count < _Nx || _Count - _Nx <= _Mypair._Myval2._Myres - _Old_size) {
    // DEBUG:             // either we are shrinking, or the growth fits
    // DEBUG:             // may temporarily overflow; OK because size_type must be unsigned
    // DEBUG:             const auto _New_size = _Old_size + _Count - _Nx;
    // DEBUG:             _ASAN_STRING_REMOVE(*this);
    // DEBUG:             _Mypair._Myval2._Mysize = _New_size;
    // DEBUG:             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
    // DEBUG:             _Elem* const _Insert_at = _Old_ptr + _Off;
    // DEBUG:             _Traits::move(_Insert_at + _Count, _Insert_at + _Nx, _Old_size - _Nx - _Off + 1);
    // DEBUG:             _Traits::assign(_Insert_at, _Count, _Ch);
    // DEBUG:             _ASAN_STRING_CREATE(*this);
    // DEBUG:             return *this;
    // DEBUG:         }
    // DEBUG: 
    // DEBUG:         return _Reallocate_grow_by(
    // DEBUG:             _Count - _Nx,
    // DEBUG:             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Off,
    // DEBUG:                 const size_type _Nx, const size_type _Count, const _Elem _Ch) _STATIC_CALL_OPERATOR {
    // DEBUG:                 _Traits::copy(_New_ptr, _Old_ptr, _Off);
    // DEBUG:                 _Traits::assign(_New_ptr + _Off, _Count, _Ch);
    // DEBUG:                 _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off + _Nx, _Old_size - _Nx - _Off + 1);
    // DEBUG:             },
    // DEBUG:             _Off, _Nx, _Count, _Ch);
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _CONSTEXPR20 basic_string& replace(
    // DEBUG:         const const_iterator _First, const const_iterator _Last, const basic_string& _Right) {
    // DEBUG:         // replace [_First, _Last) with _Right
    // DEBUG:         _STD _Adl_verify_range(_First, _Last);
    // DEBUG: #if _ITERATOR_DEBUG_LEVEL != 0
    // DEBUG:         _STL_VERIFY(_First._Getcont() == _STD addressof(_Mypair._Myval2), "string iterators incompatible");
    // DEBUG: #endif // _ITERATOR_DEBUG_LEVEL != 0
    // DEBUG:         return replace(static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr()),
    // DEBUG:             static_cast<size_type>(_Last._Ptr - _First._Ptr), _Right);
    // DEBUG:     }
    // DEBUG: 
    // DEBUG: #if _HAS_CXX17
    // DEBUG:     template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
    // DEBUG:     _CONSTEXPR20 basic_string& replace(
    // DEBUG:         const const_iterator _First, const const_iterator _Last, const _StringViewIsh& _Right) {
    // DEBUG:         // replace [_First, _Last) with _Right
    // DEBUG:         _STD _Adl_verify_range(_First, _Last);
    // DEBUG: #if _ITERATOR_DEBUG_LEVEL != 0
    // DEBUG:         _STL_VERIFY(_First._Getcont() == _STD addressof(_Mypair._Myval2), "string iterators incompatible");
    // DEBUG: #endif // _ITERATOR_DEBUG_LEVEL != 0
    // DEBUG:         return replace(static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr()),
    // DEBUG:             static_cast<size_type>(_Last._Ptr - _First._Ptr), _Right);
    // DEBUG:     }
    // DEBUG: #endif // _HAS_CXX17
    // DEBUG: 
    // DEBUG:     _CONSTEXPR20 basic_string& replace(const const_iterator _First, const const_iterator _Last,
    // DEBUG:         _In_reads_(_Count) const _Elem* const _Ptr, const size_type _Count) {
    // DEBUG:         // replace [_First, _Last) with [_Ptr, _Ptr + _Count)
    // DEBUG:         _STD _Adl_verify_range(_First, _Last);
    // DEBUG: #if _ITERATOR_DEBUG_LEVEL != 0
    // DEBUG:         _STL_VERIFY(_First._Getcont() == _STD addressof(_Mypair._Myval2), "string iterators incompatible");
    // DEBUG: #endif // _ITERATOR_DEBUG_LEVEL != 0
    // DEBUG:         return replace(static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr()),
    // DEBUG:             static_cast<size_type>(_Last._Ptr - _First._Ptr), _Ptr, _Count);
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _CONSTEXPR20 basic_string& replace(
    // DEBUG:         const const_iterator _First, const const_iterator _Last, _In_z_ const _Elem* const _Ptr) {
    // DEBUG:         // replace [_First, _Last) with [_Ptr, <null>)
    // DEBUG:         _STD _Adl_verify_range(_First, _Last);
    // DEBUG: #if _ITERATOR_DEBUG_LEVEL != 0
    // DEBUG:         _STL_VERIFY(_First._Getcont() == _STD addressof(_Mypair._Myval2), "string iterators incompatible");
    // DEBUG: #endif // _ITERATOR_DEBUG_LEVEL != 0
    // DEBUG:         return replace(static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr()),
    // DEBUG:             static_cast<size_type>(_Last._Ptr - _First._Ptr), _Ptr);
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _CONSTEXPR20 basic_string& replace(
    // DEBUG:         const const_iterator _First, const const_iterator _Last, const size_type _Count, const _Elem _Ch) {
    // DEBUG:         // replace [_First, _Last) with _Count * _Ch
    // DEBUG:         _STD _Adl_verify_range(_First, _Last);
    // DEBUG: #if _ITERATOR_DEBUG_LEVEL != 0
    // DEBUG:         _STL_VERIFY(_First._Getcont() == _STD addressof(_Mypair._Myval2), "string iterators incompatible");
    // DEBUG: #endif // _ITERATOR_DEBUG_LEVEL != 0
    // DEBUG:         return replace(static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr()),
    // DEBUG:             static_cast<size_type>(_Last._Ptr - _First._Ptr), _Count, _Ch);
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
    // DEBUG:     _CONSTEXPR20 basic_string& replace(
    // DEBUG:         const const_iterator _First, const const_iterator _Last, const _Iter _First2, const _Iter _Last2) {
    // DEBUG:         // replace [_First, _Last) with [_First2, _Last2), input iterators
    // DEBUG:         _STD _Adl_verify_range(_First, _Last);
    // DEBUG: #if _ITERATOR_DEBUG_LEVEL != 0
    // DEBUG:         _STL_VERIFY(_First._Getcont() == _STD addressof(_Mypair._Myval2), "string iterators incompatible");
    // DEBUG: #endif // _ITERATOR_DEBUG_LEVEL != 0
    // DEBUG:         const auto _Off    = static_cast<size_type>(_STD _Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr());
    // DEBUG:         const auto _Length = static_cast<size_type>(_Last._Ptr - _First._Ptr);
    // DEBUG:         _STD _Adl_verify_range(_First2, _Last2);
    // DEBUG:         const auto _UFirst2 = _STD _Get_unwrapped(_First2);
    // DEBUG:         const auto _ULast2  = _STD _Get_unwrapped(_Last2);
    // DEBUG:         if constexpr (_Is_elem_cptr<decltype(_UFirst2)>::value) {
    // DEBUG:             return replace(
    // DEBUG:                 _Off, _Length, _UFirst2, _STD _Convert_size<size_type>(static_cast<size_t>(_ULast2 - _UFirst2)));
    // DEBUG:         } else {
    // DEBUG:             const basic_string _Right(_UFirst2, _ULast2, get_allocator());
    // DEBUG:             return replace(_Off, _Length, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
    // DEBUG:         }
    // DEBUG:     }
    // DEBUG: 
    // DEBUG: #if _HAS_CXX23
    // DEBUG:     template <_Container_compatible_range<_Elem> _Rng>
    // DEBUG:     constexpr basic_string& replace_with_range(const const_iterator _First, const const_iterator _Last, _Rng&& _Range) {
    // DEBUG:         _STD _Adl_verify_range(_First, _Last);
    // DEBUG: #if _ITERATOR_DEBUG_LEVEL != 0
    // DEBUG:         _STL_VERIFY(_First._Getcont() == _STD addressof(_Mypair._Myval2), "string iterators incompatible");
    // DEBUG: #endif // _ITERATOR_DEBUG_LEVEL != 0
    // DEBUG:         const auto _Off    = static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr());
    // DEBUG:         const auto _Length = static_cast<size_type>(_Last._Ptr - _First._Ptr);
    // DEBUG: 
    // DEBUG:         if constexpr (_RANGES sized_range<_Rng> && _Contiguous_range_of<_Rng, _Elem>) {
    // DEBUG:             const auto _Count = _Convert_size<size_type>(_To_unsigned_like(_RANGES size(_Range)));
    // DEBUG:             return replace(_Off, _Length, _RANGES data(_Range), _Count);
    // DEBUG:         } else {
    // DEBUG:             const basic_string _Right(from_range, _Range, get_allocator());
    // DEBUG:             return replace(_Off, _Length, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
    // DEBUG:         }
    // DEBUG:     }
    // DEBUG: #endif // _HAS_CXX23
    // DEBUG: 
    // DEBUG:     _NODISCARD _CONSTEXPR20 iterator begin() noexcept {
    // DEBUG:         return iterator(_Refancy<pointer>(_Mypair._Myval2._Myptr()), _STD addressof(_Mypair._Myval2));
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _NODISCARD _CONSTEXPR20 const_iterator begin() const noexcept {
    // DEBUG:         return const_iterator(_Refancy<const_pointer>(_Mypair._Myval2._Myptr()), _STD addressof(_Mypair._Myval2));
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _NODISCARD _CONSTEXPR20 iterator end() noexcept {
    // DEBUG:         return iterator(
    // DEBUG:             _Refancy<pointer>(_Mypair._Myval2._Myptr()) + static_cast<difference_type>(_Mypair._Myval2._Mysize),
    // DEBUG:             _STD addressof(_Mypair._Myval2));
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _NODISCARD _CONSTEXPR20 const_iterator end() const noexcept {
    // DEBUG:         return const_iterator(
    // DEBUG:             _Refancy<const_pointer>(_Mypair._Myval2._Myptr()) + static_cast<difference_type>(_Mypair._Myval2._Mysize),
    // DEBUG:             _STD addressof(_Mypair._Myval2));
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _NODISCARD _CONSTEXPR20 _Elem* _Unchecked_begin() noexcept {
    // DEBUG:         return _Mypair._Myval2._Myptr();
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _NODISCARD _CONSTEXPR20 const _Elem* _Unchecked_begin() const noexcept {
    // DEBUG:         return _Mypair._Myval2._Myptr();
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _NODISCARD _CONSTEXPR20 _Elem* _Unchecked_end() noexcept {
    // DEBUG:         return _Mypair._Myval2._Myptr() + _Mypair._Myval2._Mysize;
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _NODISCARD _CONSTEXPR20 const _Elem* _Unchecked_end() const noexcept {
    // DEBUG:         return _Mypair._Myval2._Myptr() + _Mypair._Myval2._Mysize;
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _NODISCARD _CONSTEXPR20 reverse_iterator rbegin() noexcept {
    // DEBUG:         return reverse_iterator(end());
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _NODISCARD _CONSTEXPR20 const_reverse_iterator rbegin() const noexcept {
    // DEBUG:         return const_reverse_iterator(end());
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _NODISCARD _CONSTEXPR20 reverse_iterator rend() noexcept {
    // DEBUG:         return reverse_iterator(begin());
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _NODISCARD _CONSTEXPR20 const_reverse_iterator rend() const noexcept {
    // DEBUG:         return const_reverse_iterator(begin());
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _NODISCARD _CONSTEXPR20 const_iterator cbegin() const noexcept {
    // DEBUG:         return begin();
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _NODISCARD _CONSTEXPR20 const_iterator cend() const noexcept {
    // DEBUG:         return end();
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _NODISCARD _CONSTEXPR20 const_reverse_iterator crbegin() const noexcept {
    // DEBUG:         return rbegin();
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _NODISCARD _CONSTEXPR20 const_reverse_iterator crend() const noexcept {
    // DEBUG:         return rend();
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _CONSTEXPR20 void shrink_to_fit() { // reduce capacity
    // DEBUG:         auto& _My_data = _Mypair._Myval2;
    // DEBUG: 
    // DEBUG:         if (!_My_data._Large_mode_engaged()) { // can't shrink from small mode
    // DEBUG:             return;
    // DEBUG:         }
    // DEBUG: 
    // DEBUG:         if (_My_data._Mysize <= _Small_string_capacity) {
    // DEBUG:             _Become_small();
    // DEBUG:             return;
    // DEBUG:         }
    // DEBUG: 
    // DEBUG:         size_type _Target_capacity = (_STD min)(_My_data._Mysize | _Alloc_mask, max_size());
    // DEBUG:         if (_Target_capacity < _My_data._Myres) { // worth shrinking, do it
    // DEBUG:             auto& _Al = _Getal();
    // DEBUG:             const pointer _New_ptr =
    // DEBUG:                 _Allocate_for_capacity<_Allocation_policy::_Exactly>(_Al, _Target_capacity); // throws
    // DEBUG:             _ASAN_STRING_REMOVE(*this);
    // DEBUG: 
    // DEBUG:             _My_data._Orphan_all();
    // DEBUG:             _Traits::copy(_Unfancy(_New_ptr), _Unfancy(_My_data._Bx._Ptr), _My_data._Mysize + 1);
    // DEBUG:             _Deallocate_for_capacity(_Al, _My_data._Bx._Ptr, _My_data._Myres);
    // DEBUG:             _My_data._Bx._Ptr = _New_ptr;
    // DEBUG:             _My_data._Myres   = _Target_capacity;
    // DEBUG:             _ASAN_STRING_CREATE(*this);
    // DEBUG:         }
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _NODISCARD _CONSTEXPR20 reference at(const size_type _Off) {
    // DEBUG:         _Mypair._Myval2._Check_offset_exclusive(_Off);
    // DEBUG:         return _Mypair._Myval2._Myptr()[_Off];
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _NODISCARD _CONSTEXPR20 const_reference at(const size_type _Off) const {
    // DEBUG:         _Mypair._Myval2._Check_offset_exclusive(_Off);
    // DEBUG:         return _Mypair._Myval2._Myptr()[_Off];
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _NODISCARD _CONSTEXPR20 reference operator[](const size_type _Off) noexcept /* strengthened */ {
    // DEBUG: #if _CONTAINER_DEBUG_LEVEL > 0
    // DEBUG:         _STL_VERIFY(_Off <= _Mypair._Myval2._Mysize, "string subscript out of range");
    // DEBUG: #endif // _CONTAINER_DEBUG_LEVEL > 0
    // DEBUG:         return _Mypair._Myval2._Myptr()[_Off];
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _NODISCARD _CONSTEXPR20 const_reference operator[](const size_type _Off) const noexcept
    // DEBUG:     /* strengthened */ {
    // DEBUG: #if _CONTAINER_DEBUG_LEVEL > 0
    // DEBUG:         _STL_VERIFY(_Off <= _Mypair._Myval2._Mysize, "string subscript out of range");
    // DEBUG: #endif // _CONTAINER_DEBUG_LEVEL > 0
    // DEBUG:         return _Mypair._Myval2._Myptr()[_Off];
    // DEBUG:     }
    // DEBUG: 
    // DEBUG: #if _HAS_CXX17
    // DEBUG:     /* implicit */ _CONSTEXPR20 operator basic_string_view<_Elem, _Traits>() const noexcept {
    // DEBUG:         // return a string_view around *this's character-type sequence
    // DEBUG:         return basic_string_view<_Elem, _Traits>{_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize};
    // DEBUG:     }
    // DEBUG: #endif // _HAS_CXX17
    // DEBUG: 
    // DEBUG:     _CONSTEXPR20 void push_back(const _Elem _Ch) { // insert element at end
    // DEBUG:         const size_type _Old_size = _Mypair._Myval2._Mysize;
    // DEBUG:         if (_Old_size < _Mypair._Myval2._Myres) {
    // DEBUG:             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + 1);
    // DEBUG:             _Mypair._Myval2._Mysize = _Old_size + 1;
    // DEBUG:             _Elem* const _Ptr       = _Mypair._Myval2._Myptr();
    // DEBUG:             _Traits::assign(_Ptr[_Old_size], _Ch);
    // DEBUG:             _Traits::assign(_Ptr[_Old_size + 1], _Elem());
    // DEBUG:             return;
    // DEBUG:         }
    // DEBUG: 
    // DEBUG:         _Reallocate_grow_by(
    // DEBUG:             1,
    // DEBUG:             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem _Ch)
    // DEBUG:                 _STATIC_CALL_OPERATOR {
    // DEBUG:                     _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
    // DEBUG:                     _Traits::assign(_New_ptr[_Old_size], _Ch);
    // DEBUG:                     _Traits::assign(_New_ptr[_Old_size + 1], _Elem());
    // DEBUG:                 },
    // DEBUG:             _Ch);
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _CONSTEXPR20 void pop_back() noexcept /* strengthened */ {
    // DEBUG:         const size_type _Old_size = _Mypair._Myval2._Mysize;
    // DEBUG: #if _ITERATOR_DEBUG_LEVEL >= 1
    // DEBUG:         _STL_VERIFY(_Old_size != 0, "invalid to pop_back empty string");
    // DEBUG: #endif // _ITERATOR_DEBUG_LEVEL >= 1
    // DEBUG:         _Eos(_Old_size - 1);
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _NODISCARD _CONSTEXPR20 reference front() noexcept /* strengthened */ {
    // DEBUG: #if _CONTAINER_DEBUG_LEVEL > 0
    // DEBUG:         _STL_VERIFY(_Mypair._Myval2._Mysize != 0, "front() called on empty string");
    // DEBUG: #endif // _CONTAINER_DEBUG_LEVEL > 0
    // DEBUG: 
    // DEBUG:         return _Mypair._Myval2._Myptr()[0];
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _NODISCARD _CONSTEXPR20 const_reference front() const noexcept /* strengthened */ {
    // DEBUG: #if _CONTAINER_DEBUG_LEVEL > 0
    // DEBUG:         _STL_VERIFY(_Mypair._Myval2._Mysize != 0, "front() called on empty string");
    // DEBUG: #endif // _CONTAINER_DEBUG_LEVEL > 0
    // DEBUG: 
    // DEBUG:         return _Mypair._Myval2._Myptr()[0];
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _NODISCARD _CONSTEXPR20 reference back() noexcept /* strengthened */ {
    // DEBUG: #if _CONTAINER_DEBUG_LEVEL > 0
    // DEBUG:         _STL_VERIFY(_Mypair._Myval2._Mysize != 0, "back() called on empty string");
    // DEBUG: #endif // _CONTAINER_DEBUG_LEVEL > 0
    // DEBUG: 
    // DEBUG:         return _Mypair._Myval2._Myptr()[_Mypair._Myval2._Mysize - 1];
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _NODISCARD _CONSTEXPR20 const_reference back() const noexcept /* strengthened */ {
    // DEBUG: #if _CONTAINER_DEBUG_LEVEL > 0
    // DEBUG:         _STL_VERIFY(_Mypair._Myval2._Mysize != 0, "back() called on empty string");
    // DEBUG: #endif // _CONTAINER_DEBUG_LEVEL > 0
    // DEBUG: 
    // DEBUG:         return _Mypair._Myval2._Myptr()[_Mypair._Myval2._Mysize - 1];
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _NODISCARD _CONSTEXPR20 _Ret_z_ const _Elem* c_str() const noexcept {
    // DEBUG:         return _Mypair._Myval2._Myptr();
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _NODISCARD _CONSTEXPR20 _Ret_z_ const _Elem* data() const noexcept {
    // DEBUG:         return _Mypair._Myval2._Myptr();
    // DEBUG:     }
    // DEBUG: 
    // DEBUG: #if _HAS_CXX17
    // DEBUG:     _NODISCARD _CONSTEXPR20 _Ret_z_ _Elem* data() noexcept {
    // DEBUG:         return _Mypair._Myval2._Myptr();
    // DEBUG:     }
    // DEBUG: #endif // _HAS_CXX17
    // DEBUG: 
    // DEBUG:     _NODISCARD _CONSTEXPR20 size_type length() const noexcept {
    // DEBUG:         return _Mypair._Myval2._Mysize;
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _NODISCARD _CONSTEXPR20 size_type size() const noexcept {
    // DEBUG:         return _Mypair._Myval2._Mysize;
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _NODISCARD _CONSTEXPR20 size_type max_size() const noexcept {
    // DEBUG:         const size_type _Alloc_max   = _Alty_traits::max_size(_Getal());
    // DEBUG:         const size_type _Storage_max = // can always store small string
    // DEBUG:             (_STD max)(_Alloc_max, static_cast<size_type>(_BUF_SIZE));
    // DEBUG:         return (_STD min)(static_cast<size_type>(_STD _Max_limit<difference_type>()),
    // DEBUG:             _Storage_max - 1 // -1 is for null terminator and/or npos
    // DEBUG:         );
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _New_size, const _Elem _Ch = _Elem()) {
    // DEBUG:         // determine new length, padding with _Ch elements as needed
    // DEBUG:         const size_type _Old_size = size();
    // DEBUG:         if (_New_size <= _Old_size) {
    // DEBUG:             _Eos(_New_size);
    // DEBUG:         } else {
    // DEBUG:             append(_New_size - _Old_size, _Ch);
    // DEBUG:         }
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     template <class _Operation>
    // DEBUG:     constexpr void
    // DEBUG: #if _HAS_CXX23
    // DEBUG:         resize_and_overwrite
    // DEBUG: #else // ^^^ _HAS_CXX23 / !_HAS_CXX23 vvv
    // DEBUG:         _Resize_and_overwrite
    // DEBUG: #endif // ^^^ !_HAS_CXX23 ^^^
    // DEBUG:         (_CRT_GUARDOVERFLOW const size_type _New_size, _Operation _Op) {
    // DEBUG:         if (_Mypair._Myval2._Myres < _New_size) {
    // DEBUG:             _Reallocate_grow_by(_New_size - _Mypair._Myval2._Mysize,
    // DEBUG:                 [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size)
    // DEBUG:                     _STATIC_CALL_OPERATOR { _Traits::copy(_New_ptr, _Old_ptr, _Old_size + 1); });
    // DEBUG:         } else {
    // DEBUG:             _ASAN_STRING_MODIFY(*this, _Mypair._Myval2._Mysize, _New_size);
    // DEBUG:             _Mypair._Myval2._Mysize = _New_size;
    // DEBUG:         }
    // DEBUG: 
    // DEBUG:         auto _Arg_ptr                   = _Mypair._Myval2._Myptr();
    // DEBUG:         auto _Arg_size                  = _New_size;
    // DEBUG:         const auto _Result_size         = _STD move(_Op)(_Arg_ptr, _Arg_size);
    // DEBUG:         const auto _Result_as_size_type = static_cast<size_type>(_Result_size);
    // DEBUG: #if _CONTAINER_DEBUG_LEVEL > 0
    // DEBUG:         _STL_VERIFY(_Result_size >= 0, "the returned size can't be smaller than 0");
    // DEBUG:         _STL_VERIFY(_Result_as_size_type <= _New_size, "the returned size can't be greater than the passed size");
    // DEBUG: #endif // _CONTAINER_DEBUG_LEVEL > 0
    // DEBUG:         _Eos(_Result_as_size_type);
    // DEBUG:     }
    // DEBUG: 
    // DEBUG: #if _HAS_CXX23
    // DEBUG:     template <class _Operation>
    // DEBUG:     constexpr void _Resize_and_overwrite(_CRT_GUARDOVERFLOW const size_type _New_size, _Operation _Op) {
    // DEBUG:         resize_and_overwrite(_New_size, _Op);
    // DEBUG:     }
    // DEBUG: #endif // _HAS_CXX23
    // DEBUG: 
    // DEBUG:     _NODISCARD _CONSTEXPR20 size_type capacity() const noexcept {
    // DEBUG:         return _Mypair._Myval2._Myres;
    // DEBUG:     }
    // DEBUG: 
    // DEBUG: #if _HAS_CXX20
    // DEBUG:     constexpr void reserve(_CRT_GUARDOVERFLOW const size_type _Newcap) {
    // DEBUG:         // determine new minimum length of allocated storage
    // DEBUG:         if (_Mypair._Myval2._Myres >= _Newcap) { // requested capacity is not larger than current capacity, ignore
    // DEBUG:             return; // nothing to do
    // DEBUG:         }
    // DEBUG: 
    // DEBUG:         const size_type _Old_size = _Mypair._Myval2._Mysize;
    // DEBUG:         _Reallocate_grow_by(_Newcap - _Old_size,
    // DEBUG:             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size)
    // DEBUG:                 _STATIC_CALL_OPERATOR { _Traits::copy(_New_ptr, _Old_ptr, _Old_size + 1); });
    // DEBUG: 
    // DEBUG:         _Mypair._Myval2._Mysize = _Old_size;
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _CXX20_DEPRECATE_STRING_RESERVE_WITHOUT_ARGUMENT void reserve() {
    // DEBUG:         if (_Mypair._Myval2._Mysize == 0 && _Mypair._Myval2._Large_mode_engaged()) {
    // DEBUG:             _Become_small();
    // DEBUG:         }
    // DEBUG:     }
    // DEBUG: #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
    // DEBUG:     void reserve(_CRT_GUARDOVERFLOW const size_type _Newcap = 0) { // determine new minimum length of allocated storage
    // DEBUG:         if (_Mypair._Myval2._Mysize > _Newcap) { // requested capacity is not large enough for current size, ignore
    // DEBUG:             return; // nothing to do
    // DEBUG:         }
    // DEBUG: 
    // DEBUG:         if (_Mypair._Myval2._Myres == _Newcap) { // we're already at the requested capacity
    // DEBUG:             return; // nothing to do
    // DEBUG:         }
    // DEBUG: 
    // DEBUG:         if (_Mypair._Myval2._Myres < _Newcap) { // reallocate to grow
    // DEBUG:             const size_type _Old_size = _Mypair._Myval2._Mysize;
    // DEBUG:             _Reallocate_grow_by(_Newcap - _Old_size,
    // DEBUG:                 [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size)
    // DEBUG:                     _STATIC_CALL_OPERATOR { _Traits::copy(_New_ptr, _Old_ptr, _Old_size + 1); });
    // DEBUG: 
    // DEBUG:             _Mypair._Myval2._Mysize = _Old_size;
    // DEBUG:             return;
    // DEBUG:         }
    // DEBUG: 
    // DEBUG:         if (_Newcap <= _Small_string_capacity && _Mypair._Myval2._Large_mode_engaged()) {
    // DEBUG:             // deallocate everything; switch back to "small" mode
    // DEBUG:             _Become_small();
    // DEBUG:             return;
    // DEBUG:         }
    // DEBUG: 
    // DEBUG:         // ignore requests to reserve to [_Small_string_capacity + 1, _Myres)
    // DEBUG:     }
    // DEBUG: #endif // ^^^ !_HAS_CXX20 ^^^
    // DEBUG: 
    // DEBUG:     _NODISCARD_EMPTY_MEMBER _CONSTEXPR20 bool empty() const noexcept {
    // DEBUG:         return _Mypair._Myval2._Mysize == 0;
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _CONSTEXPR20 size_type copy(
    // DEBUG:         _Out_writes_(_Count) _Elem* const _Ptr, size_type _Count, const size_type _Off = 0) const {
    // DEBUG:         // copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
    // DEBUG:         _Mypair._Myval2._Check_offset(_Off);
    // DEBUG:         _Count = _Mypair._Myval2._Clamp_suffix_size(_Off, _Count);
    // DEBUG:         _Traits::copy(_Ptr, _Mypair._Myval2._Myptr() + _Off, _Count);
    // DEBUG:         return _Count;
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _CONSTEXPR20 _Pre_satisfies_(_Dest_size >= _Count) size_type
    // DEBUG:         _Copy_s(_Out_writes_all_(_Dest_size) _Elem* const _Dest, const size_type _Dest_size, size_type _Count,
    // DEBUG:             const size_type _Off = 0) const {
    // DEBUG:         // copy [_Off, _Off + _Count) to [_Dest, _Dest + _Dest_size)
    // DEBUG:         _Mypair._Myval2._Check_offset(_Off);
    // DEBUG:         _Count = _Mypair._Myval2._Clamp_suffix_size(_Off, _Count);
    // DEBUG:         _Traits::_Copy_s(_Dest, _Dest_size, _Mypair._Myval2._Myptr() + _Off, _Count);
    // DEBUG:         return _Count;
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     static _CONSTEXPR20 void _Swap_bx_large_with_small(_Scary_val& _Starts_large, _Scary_val& _Starts_small) noexcept {
    // DEBUG:         // exchange a string in large mode with one in small mode
    // DEBUG:         const pointer _Ptr = _Starts_large._Bx._Ptr;
    // DEBUG:         _Starts_large._Bx._Switch_to_buf();
    // DEBUG:         _Traits::copy(_Starts_large._Bx._Buf, _Starts_small._Bx._Buf, _BUF_SIZE);
    // DEBUG: 
    // DEBUG:         _Construct_in_place(_Starts_small._Bx._Ptr, _Ptr);
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _CONSTEXPR20 void _Swap_data(basic_string& _Right) noexcept {
    // DEBUG:         using _STD swap;
    // DEBUG: 
    // DEBUG:         auto& _My_data    = _Mypair._Myval2;
    // DEBUG:         auto& _Right_data = _Right._Mypair._Myval2;
    // DEBUG: 
    // DEBUG: #if !defined(_INSERT_STRING_ANNOTATION)
    // DEBUG:         if constexpr (_Can_memcpy_val) {
    // DEBUG: #if _HAS_CXX20
    // DEBUG:             if (!_STD is_constant_evaluated())
    // DEBUG: #endif // _HAS_CXX20
    // DEBUG:             {
    // DEBUG:                 const auto _My_data_mem =
    // DEBUG:                     reinterpret_cast<unsigned char*>(_STD addressof(_My_data)) + _Memcpy_val_offset;
    // DEBUG:                 const auto _Right_data_mem =
    // DEBUG:                     reinterpret_cast<unsigned char*>(_STD addressof(_Right_data)) + _Memcpy_val_offset;
    // DEBUG:                 unsigned char _Temp_mem[_Memcpy_val_size];
    // DEBUG:                 _CSTD memcpy(_Temp_mem, _My_data_mem, _Memcpy_val_size);
    // DEBUG:                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);
    // DEBUG:                 _CSTD memcpy(_Right_data_mem, _Temp_mem, _Memcpy_val_size);
    // DEBUG: 
    // DEBUG:                 return;
    // DEBUG:             }
    // DEBUG:         }
    // DEBUG: #endif // !defined(_INSERT_STRING_ANNOTATION)
    // DEBUG: 
    // DEBUG:         const bool _My_large    = _My_data._Large_mode_engaged();
    // DEBUG:         const bool _Right_large = _Right_data._Large_mode_engaged();
    // DEBUG: 
    // DEBUG:         if (_My_large && _Right_large) { // swap buffers, iterators preserved
    // DEBUG:             swap(_My_data._Bx._Ptr, _Right_data._Bx._Ptr); // intentional ADL
    // DEBUG:         } else if (_My_large) { // swap large with small
    // DEBUG:             _Swap_bx_large_with_small(_My_data, _Right_data);
    // DEBUG:         } else if (_Right_large) { // swap small with large
    // DEBUG:             _Swap_bx_large_with_small(_Right_data, _My_data);
    // DEBUG:         } else {
    // DEBUG:             _Elem _Temp_buf[_BUF_SIZE];
    // DEBUG:             _Traits::copy(_Temp_buf, _My_data._Bx._Buf, _My_data._Mysize + 1);
    // DEBUG:             _Traits::copy(_My_data._Bx._Buf, _Right_data._Bx._Buf, _Right_data._Mysize + 1);
    // DEBUG:             _Traits::copy(_Right_data._Bx._Buf, _Temp_buf, _My_data._Mysize + 1);
    // DEBUG:         }
    // DEBUG: 
    // DEBUG:         _STD swap(_My_data._Mysize, _Right_data._Mysize);
    // DEBUG:         _STD swap(_My_data._Myres, _Right_data._Myres);
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _CONSTEXPR20 void swap(basic_string& _Right) noexcept /* strengthened */ {
    // DEBUG:         if (this != _STD addressof(_Right)) {
    // DEBUG:             _Pocs(_Getal(), _Right._Getal());
    // DEBUG: 
    // DEBUG: #if _ITERATOR_DEBUG_LEVEL != 0
    // DEBUG:             auto& _My_data    = _Mypair._Myval2;
    // DEBUG:             auto& _Right_data = _Right._Mypair._Myval2;
    // DEBUG: 
    // DEBUG:             if (!_My_data._Large_mode_engaged()) {
    // DEBUG:                 _My_data._Orphan_all();
    // DEBUG:             }
    // DEBUG: 
    // DEBUG:             if (!_Right_data._Large_mode_engaged()) {
    // DEBUG:                 _Right_data._Orphan_all();
    // DEBUG:             }
    // DEBUG: 
    // DEBUG:             _My_data._Swap_proxy_and_iterators(_Right_data);
    // DEBUG: #endif // _ITERATOR_DEBUG_LEVEL != 0
    // DEBUG: 
    // DEBUG:             _Swap_data(_Right);
    // DEBUG:         }
    // DEBUG:     }
    // DEBUG: 
    // DEBUG: #if _HAS_CXX17
    // DEBUG:     template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
    // DEBUG:     _NODISCARD _CONSTEXPR20 size_type find(const _StringViewIsh& _Right, const size_type _Off = 0) const
    // DEBUG:         noexcept(_Is_nothrow_convertible_v<const _StringViewIsh&, basic_string_view<_Elem, _Traits>>) {
    // DEBUG:         // look for _Right beginning at or after _Off
    // DEBUG:         basic_string_view<_Elem, _Traits> _As_view = _Right;
    // DEBUG:         return static_cast<size_type>(_Traits_find<_Traits>(
    // DEBUG:             _Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _As_view.data(), _As_view.size()));
    // DEBUG:     }
    // DEBUG: #endif // _HAS_CXX17
    // DEBUG: 
    // DEBUG:     _NODISCARD _CONSTEXPR20 size_type find(const basic_string& _Right, const size_type _Off = 0) const noexcept {
    // DEBUG:         // look for _Right beginning at or after _Off
    // DEBUG:         return static_cast<size_type>(_Traits_find<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off,
    // DEBUG:             _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize));
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _NODISCARD _CONSTEXPR20 size_type find(_In_reads_(_Count) const _Elem* const _Ptr, const size_type _Off,
    // DEBUG:         const size_type _Count) const noexcept /* strengthened */ {
    // DEBUG:         // look for [_Ptr, _Ptr + _Count) beginning at or after _Off
    // DEBUG:         return static_cast<size_type>(
    // DEBUG:             _Traits_find<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr, _Count));
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _NODISCARD _CONSTEXPR20 size_type find(_In_z_ const _Elem* const _Ptr, const size_type _Off = 0) const noexcept
    // DEBUG:     /* strengthened */ {
    // DEBUG:         // look for [_Ptr, <null>) beginning at or after _Off
    // DEBUG:         return static_cast<size_type>(_Traits_find<_Traits>(
    // DEBUG:             _Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr, _Traits::length(_Ptr)));
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _NODISCARD _CONSTEXPR20 size_type find(const _Elem _Ch, const size_type _Off = 0) const noexcept {
    // DEBUG:         // look for _Ch at or after _Off
    // DEBUG:         return static_cast<size_type>(
    // DEBUG:             _Traits_find_ch<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ch));
    // DEBUG:     }
    // DEBUG: 
    // DEBUG: #if _HAS_CXX17
    // DEBUG:     template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
    // DEBUG:     _NODISCARD _CONSTEXPR20 size_type rfind(const _StringViewIsh& _Right, const size_type _Off = npos) const
    // DEBUG:         noexcept(_Is_nothrow_convertible_v<const _StringViewIsh&, basic_string_view<_Elem, _Traits>>) {
    // DEBUG:         // look for _Right beginning before _Off
    // DEBUG:         basic_string_view<_Elem, _Traits> _As_view = _Right;
    // DEBUG:         return static_cast<size_type>(_Traits_rfind<_Traits>(
    // DEBUG:             _Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _As_view.data(), _As_view.size()));
    // DEBUG:     }
    // DEBUG: #endif // _HAS_CXX17
    // DEBUG: 
    // DEBUG:     _NODISCARD _CONSTEXPR20 size_type rfind(const basic_string& _Right, const size_type _Off = npos) const noexcept {
    // DEBUG:         // look for _Right beginning before _Off
    // DEBUG:         return static_cast<size_type>(_Traits_rfind<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off,
    // DEBUG:             _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize));
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _NODISCARD _CONSTEXPR20 size_type rfind(_In_reads_(_Count) const _Elem* const _Ptr, const size_type _Off,
    // DEBUG:         const size_type _Count) const noexcept /* strengthened */ {
    // DEBUG:         // look for [_Ptr, _Ptr + _Count) beginning before _Off
    // DEBUG:         return static_cast<size_type>(
    // DEBUG:             _Traits_rfind<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr, _Count));
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _NODISCARD _CONSTEXPR20 size_type rfind(_In_z_ const _Elem* const _Ptr, const size_type _Off = npos) const noexcept
    // DEBUG:     /* strengthened */ {
    // DEBUG:         // look for [_Ptr, <null>) beginning before _Off
    // DEBUG:         return static_cast<size_type>(_Traits_rfind<_Traits>(
    // DEBUG:             _Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr, _Traits::length(_Ptr)));
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _NODISCARD _CONSTEXPR20 size_type rfind(const _Elem _Ch, const size_type _Off = npos) const noexcept {
    // DEBUG:         // look for _Ch before _Off
    // DEBUG:         return static_cast<size_type>(
    // DEBUG:             _Traits_rfind_ch<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ch));
    // DEBUG:     }
    // DEBUG: 
    // DEBUG: #if _HAS_CXX17
    // DEBUG:     template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
    // DEBUG:     _NODISCARD _CONSTEXPR20 size_type find_first_of(const _StringViewIsh& _Right, const size_type _Off = 0) const
    // DEBUG:         noexcept(_Is_nothrow_convertible_v<const _StringViewIsh&, basic_string_view<_Elem, _Traits>>) {
    // DEBUG:         // look for one of _Right at or after _Off
    // DEBUG:         basic_string_view<_Elem, _Traits> _As_view = _Right;
    // DEBUG:         return static_cast<size_type>(_Traits_find_first_of<_Traits>(
    // DEBUG:             _Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _As_view.data(), _As_view.size()));
    // DEBUG:     }
    // DEBUG: #endif // _HAS_CXX17
    // DEBUG: 
    // DEBUG:     _NODISCARD _CONSTEXPR20 size_type find_first_of(
    // DEBUG:         const basic_string& _Right, const size_type _Off = 0) const noexcept {
    // DEBUG:         // look for one of _Right at or after _Off
    // DEBUG:         return static_cast<size_type>(_Traits_find_first_of<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,
    // DEBUG:             _Off, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize));
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _NODISCARD _CONSTEXPR20 size_type find_first_of(_In_reads_(_Count) const _Elem* const _Ptr, const size_type _Off,
    // DEBUG:         const size_type _Count) const noexcept /* strengthened */ {
    // DEBUG:         // look for one of [_Ptr, _Ptr + _Count) at or after _Off
    // DEBUG:         return static_cast<size_type>(
    // DEBUG:             _Traits_find_first_of<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr, _Count));
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _NODISCARD _CONSTEXPR20 size_type find_first_of(
    // DEBUG:         _In_z_ const _Elem* const _Ptr, const size_type _Off = 0) const noexcept
    // DEBUG:     /* strengthened */ {
    // DEBUG:         // look for one of [_Ptr, <null>) at or after _Off
    // DEBUG:         return static_cast<size_type>(_Traits_find_first_of<_Traits>(
    // DEBUG:             _Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr, _Traits::length(_Ptr)));
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _NODISCARD _CONSTEXPR20 size_type find_first_of(const _Elem _Ch, const size_type _Off = 0) const noexcept {
    // DEBUG:         // look for _Ch at or after _Off
    // DEBUG:         return static_cast<size_type>(
    // DEBUG:             _Traits_find_ch<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ch));
    // DEBUG:     }
    // DEBUG: 
    // DEBUG: #if _HAS_CXX17
    // DEBUG:     template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
    // DEBUG:     _NODISCARD _CONSTEXPR20 size_type find_last_of(const _StringViewIsh& _Right, const size_type _Off = npos) const
    // DEBUG:         noexcept(_Is_nothrow_convertible_v<const _StringViewIsh&, basic_string_view<_Elem, _Traits>>) {
    // DEBUG:         // look for one of _Right before _Off
    // DEBUG:         basic_string_view<_Elem, _Traits> _As_view = _Right;
    // DEBUG:         return static_cast<size_type>(_Traits_find_last_of<_Traits>(
    // DEBUG:             _Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _As_view.data(), _As_view.size()));
    // DEBUG:     }
    // DEBUG: #endif // _HAS_CXX17
    // DEBUG: 
    // DEBUG:     _NODISCARD _CONSTEXPR20 size_type find_last_of(const basic_string& _Right, size_type _Off = npos) const noexcept {
    // DEBUG:         // look for one of _Right before _Off
    // DEBUG:         return static_cast<size_type>(_Traits_find_last_of<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,
    // DEBUG:             _Off, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize));
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _NODISCARD _CONSTEXPR20 size_type find_last_of(_In_reads_(_Count) const _Elem* const _Ptr, const size_type _Off,
    // DEBUG:         const size_type _Count) const noexcept /* strengthened */ {
    // DEBUG:         // look for one of [_Ptr, _Ptr + _Count) before _Off
    // DEBUG:         return static_cast<size_type>(
    // DEBUG:             _Traits_find_last_of<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr, _Count));
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _NODISCARD _CONSTEXPR20 size_type find_last_of(
    // DEBUG:         _In_z_ const _Elem* const _Ptr, const size_type _Off = npos) const noexcept /* strengthened */ {
    // DEBUG:         // look for one of [_Ptr, <null>) before _Off
    // DEBUG:         return static_cast<size_type>(_Traits_find_last_of<_Traits>(
    // DEBUG:             _Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr, _Traits::length(_Ptr)));
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _NODISCARD _CONSTEXPR20 size_type find_last_of(const _Elem _Ch, const size_type _Off = npos) const noexcept {
    // DEBUG:         // look for _Ch before _Off
    // DEBUG:         return static_cast<size_type>(
    // DEBUG:             _Traits_rfind_ch<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ch));
    // DEBUG:     }
    // DEBUG: 
    // DEBUG: #if _HAS_CXX17
    // DEBUG:     template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
    // DEBUG:     _NODISCARD _CONSTEXPR20 size_type find_first_not_of(const _StringViewIsh& _Right, const size_type _Off = 0) const
    // DEBUG:         noexcept(_Is_nothrow_convertible_v<const _StringViewIsh&, basic_string_view<_Elem, _Traits>>) {
    // DEBUG:         // look for none of _Right at or after _Off
    // DEBUG:         basic_string_view<_Elem, _Traits> _As_view = _Right;
    // DEBUG:         return static_cast<size_type>(_Traits_find_first_not_of<_Traits>(
    // DEBUG:             _Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _As_view.data(), _As_view.size()));
    // DEBUG:     }
    // DEBUG: #endif // _HAS_CXX17
    // DEBUG: 
    // DEBUG:     _NODISCARD _CONSTEXPR20 size_type find_first_not_of(
    // DEBUG:         const basic_string& _Right, const size_type _Off = 0) const noexcept {
    // DEBUG:         // look for none of _Right at or after _Off
    // DEBUG:         return static_cast<size_type>(_Traits_find_first_not_of<_Traits>(_Mypair._Myval2._Myptr(),
    // DEBUG:             _Mypair._Myval2._Mysize, _Off, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize));
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _NODISCARD _CONSTEXPR20 size_type find_first_not_of(_In_reads_(_Count) const _Elem* const _Ptr,
    // DEBUG:         const size_type _Off, const size_type _Count) const noexcept /* strengthened */ {
    // DEBUG:         // look for none of [_Ptr, _Ptr + _Count) at or after _Off
    // DEBUG:         return static_cast<size_type>(
    // DEBUG:             _Traits_find_first_not_of<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr, _Count));
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _NODISCARD _CONSTEXPR20 size_type find_first_not_of(
    // DEBUG:         _In_z_ const _Elem* const _Ptr, size_type _Off = 0) const noexcept
    // DEBUG:     /* strengthened */ {
    // DEBUG:         // look for one of [_Ptr, <null>) at or after _Off
    // DEBUG:         return static_cast<size_type>(_Traits_find_first_not_of<_Traits>(
    // DEBUG:             _Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr, _Traits::length(_Ptr)));
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _NODISCARD _CONSTEXPR20 size_type find_first_not_of(const _Elem _Ch, const size_type _Off = 0) const noexcept {
    // DEBUG:         // look for non-_Ch at or after _Off
    // DEBUG:         return static_cast<size_type>(
    // DEBUG:             _Traits_find_not_ch<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ch));
    // DEBUG:     }
    // DEBUG: 
    // DEBUG: #if _HAS_CXX17
    // DEBUG:     template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
    // DEBUG:     _NODISCARD _CONSTEXPR20 size_type find_last_not_of(const _StringViewIsh& _Right, const size_type _Off = npos) const
    // DEBUG:         noexcept(_Is_nothrow_convertible_v<const _StringViewIsh&, basic_string_view<_Elem, _Traits>>) {
    // DEBUG:         // look for none of _Right before _Off
    // DEBUG:         basic_string_view<_Elem, _Traits> _As_view = _Right;
    // DEBUG:         return static_cast<size_type>(_Traits_find_last_not_of<_Traits>(
    // DEBUG:             _Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _As_view.data(), _As_view.size()));
    // DEBUG:     }
    // DEBUG: #endif // _HAS_CXX17
    // DEBUG: 
    // DEBUG:     _NODISCARD _CONSTEXPR20 size_type find_last_not_of(
    // DEBUG:         const basic_string& _Right, const size_type _Off = npos) const noexcept {
    // DEBUG:         // look for none of _Right before _Off
    // DEBUG:         return static_cast<size_type>(_Traits_find_last_not_of<_Traits>(_Mypair._Myval2._Myptr(),
    // DEBUG:             _Mypair._Myval2._Mysize, _Off, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize));
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _NODISCARD _CONSTEXPR20 size_type find_last_not_of(_In_reads_(_Count) const _Elem* const _Ptr, const size_type _Off,
    // DEBUG:         const size_type _Count) const noexcept /* strengthened */ {
    // DEBUG:         // look for none of [_Ptr, _Ptr + _Count) before _Off
    // DEBUG:         return static_cast<size_type>(
    // DEBUG:             _Traits_find_last_not_of<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr, _Count));
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _NODISCARD _CONSTEXPR20 size_type find_last_not_of(
    // DEBUG:         _In_z_ const _Elem* const _Ptr, const size_type _Off = npos) const noexcept /* strengthened */ {
    // DEBUG:         // look for none of [_Ptr, <null>) before _Off
    // DEBUG:         return static_cast<size_type>(_Traits_find_last_not_of<_Traits>(
    // DEBUG:             _Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr, _Traits::length(_Ptr)));
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _NODISCARD _CONSTEXPR20 size_type find_last_not_of(const _Elem _Ch, const size_type _Off = npos) const noexcept {
    // DEBUG:         // look for non-_Ch before _Off
    // DEBUG:         return static_cast<size_type>(
    // DEBUG:             _Traits_rfind_not_ch<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ch));
    // DEBUG:     }
    // DEBUG: 
    // DEBUG: #if _HAS_CXX17
    // DEBUG:     _NODISCARD bool _Starts_with(const basic_string_view<_Elem, _Traits> _Right) const noexcept {
    // DEBUG:         // Used exclusively by filesystem
    // DEBUG:         return basic_string_view<_Elem, _Traits>(*this)._Starts_with(_Right);
    // DEBUG:     }
    // DEBUG: #endif // _HAS_CXX17
    // DEBUG: 
    // DEBUG:     _NODISCARD _CONSTEXPR20 basic_string substr(const size_type _Off = 0, const size_type _Count = npos)
    // DEBUG: #if _HAS_CXX23
    // DEBUG:         const&
    // DEBUG: #else
    // DEBUG:         const
    // DEBUG: #endif
    // DEBUG:     {
    // DEBUG:         // return [_Off, _Off + _Count) as new string, default-constructing its allocator
    // DEBUG:         return basic_string{*this, _Off, _Count};
    // DEBUG:     }
    // DEBUG: 
    // DEBUG: #if _HAS_CXX23
    // DEBUG:     _NODISCARD constexpr basic_string substr(const size_type _Off = 0, const size_type _Count = npos) && {
    // DEBUG:         // return [_Off, _Off + _Count) as new string, potentially moving, default-constructing its allocator
    // DEBUG:         return basic_string{_STD move(*this), _Off, _Count};
    // DEBUG:     }
    // DEBUG: #endif // _HAS_CXX23
    // DEBUG: 
    // DEBUG:     _CONSTEXPR20 bool _Equal(const basic_string& _Right) const noexcept {
    // DEBUG:         // compare [0, size()) with _Right for equality
    // DEBUG:         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,
    // DEBUG:             _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _CONSTEXPR20 bool _Equal(_In_z_ const _Elem* const _Ptr) const noexcept {
    // DEBUG:         // compare [0, size()) with _Ptr for equality
    // DEBUG:         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Ptr, _Traits::length(_Ptr));
    // DEBUG:     }
    // DEBUG: 
    // DEBUG: #if _HAS_CXX17
    // DEBUG:     template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
    // DEBUG:     _NODISCARD _CONSTEXPR20 int compare(const _StringViewIsh& _Right) const
    // DEBUG:         noexcept(_Is_nothrow_convertible_v<const _StringViewIsh&, basic_string_view<_Elem, _Traits>>) {
    // DEBUG:         // compare [0, size()) with _Right
    // DEBUG:         basic_string_view<_Elem, _Traits> _As_view = _Right;
    // DEBUG:         return _Traits_compare<_Traits>(
    // DEBUG:             _Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _As_view.data(), _As_view.size());
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
    // DEBUG:     _NODISCARD _CONSTEXPR20 int compare(const size_type _Off, const size_type _Nx, const _StringViewIsh& _Right) const {
    // DEBUG:         // compare [_Off, _Off + _Nx) with _Right
    // DEBUG:         basic_string_view<_Elem, _Traits> _As_view = _Right;
    // DEBUG:         _Mypair._Myval2._Check_offset(_Off);
    // DEBUG:         return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr() + _Off, _Mypair._Myval2._Clamp_suffix_size(_Off, _Nx),
    // DEBUG:             _As_view.data(), _As_view.size());
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
    // DEBUG:     _NODISCARD _CONSTEXPR20 int compare(const size_type _Off, const size_type _Nx, const _StringViewIsh& _Right,
    // DEBUG:         const size_type _Roff, const size_type _Count = npos) const {
    // DEBUG:         // compare [_Off, _Off + _Nx) with _Right [_Roff, _Roff + _Count)
    // DEBUG:         basic_string_view<_Elem, _Traits> _As_view = _Right;
    // DEBUG:         _Mypair._Myval2._Check_offset(_Off);
    // DEBUG:         const auto _With_substr = _As_view.substr(_Roff, _Count);
    // DEBUG:         return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr() + _Off, _Mypair._Myval2._Clamp_suffix_size(_Off, _Nx),
    // DEBUG:             _With_substr.data(), _With_substr.size());
    // DEBUG:     }
    // DEBUG: #endif // _HAS_CXX17
    // DEBUG: 
    // DEBUG:     _NODISCARD _CONSTEXPR20 int compare(const basic_string& _Right) const noexcept {
    // DEBUG:         // compare [0, size()) with _Right
    // DEBUG:         return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,
    // DEBUG:             _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _NODISCARD _CONSTEXPR20 int compare(size_type _Off, size_type _Nx, const basic_string& _Right) const {
    // DEBUG:         // compare [_Off, _Off + _Nx) with _Right
    // DEBUG:         _Mypair._Myval2._Check_offset(_Off);
    // DEBUG:         return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr() + _Off, _Mypair._Myval2._Clamp_suffix_size(_Off, _Nx),
    // DEBUG:             _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _NODISCARD _CONSTEXPR20 int compare(const size_type _Off, const size_type _Nx, const basic_string& _Right,
    // DEBUG:         const size_type _Roff, const size_type _Count = npos) const {
    // DEBUG:         // compare [_Off, _Off + _Nx) with _Right [_Roff, _Roff + _Count)
    // DEBUG:         _Mypair._Myval2._Check_offset(_Off);
    // DEBUG:         _Right._Mypair._Myval2._Check_offset(_Roff);
    // DEBUG:         return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr() + _Off, _Mypair._Myval2._Clamp_suffix_size(_Off, _Nx),
    // DEBUG:             _Right._Mypair._Myval2._Myptr() + _Roff, _Right._Mypair._Myval2._Clamp_suffix_size(_Roff, _Count));
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _NODISCARD _CONSTEXPR20 int compare(_In_z_ const _Elem* const _Ptr) const noexcept /* strengthened */ {
    // DEBUG:         // compare [0, size()) with [_Ptr, <null>)
    // DEBUG:         return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Ptr, _Traits::length(_Ptr));
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _NODISCARD _CONSTEXPR20 int compare(
    // DEBUG:         const size_type _Off, const size_type _Nx, _In_z_ const _Elem* const _Ptr) const {
    // DEBUG:         // compare [_Off, _Off + _Nx) with [_Ptr, <null>)
    // DEBUG:         _Mypair._Myval2._Check_offset(_Off);
    // DEBUG:         return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr() + _Off, _Mypair._Myval2._Clamp_suffix_size(_Off, _Nx),
    // DEBUG:             _Ptr, _Traits::length(_Ptr));
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _NODISCARD _CONSTEXPR20 int compare(const size_type _Off, const size_type _Nx,
    // DEBUG:         _In_reads_(_Count) const _Elem* const _Ptr, const size_type _Count) const {
    // DEBUG:         // compare [_Off, _Off + _Nx) with [_Ptr, _Ptr + _Count)
    // DEBUG:         _Mypair._Myval2._Check_offset(_Off);
    // DEBUG:         return _Traits_compare<_Traits>(
    // DEBUG:             _Mypair._Myval2._Myptr() + _Off, _Mypair._Myval2._Clamp_suffix_size(_Off, _Nx), _Ptr, _Count);
    // DEBUG:     }
    // DEBUG: 
    // DEBUG: #if _HAS_CXX20
    // DEBUG:     _NODISCARD constexpr bool starts_with(const basic_string_view<_Elem, _Traits> _Right) const noexcept {
    // DEBUG:         return basic_string_view<_Elem, _Traits>{_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize}.starts_with(_Right);
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _NODISCARD constexpr bool starts_with(const _Elem _Right) const noexcept {
    // DEBUG:         return basic_string_view<_Elem, _Traits>{_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize}.starts_with(_Right);
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _NODISCARD constexpr bool starts_with(const _Elem* const _Right) const noexcept /* strengthened */ {
    // DEBUG:         return basic_string_view<_Elem, _Traits>{_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize}.starts_with(_Right);
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _NODISCARD constexpr bool ends_with(const basic_string_view<_Elem, _Traits> _Right) const noexcept {
    // DEBUG:         return basic_string_view<_Elem, _Traits>{_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize}.ends_with(_Right);
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _NODISCARD constexpr bool ends_with(const _Elem _Right) const noexcept {
    // DEBUG:         return basic_string_view<_Elem, _Traits>{_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize}.ends_with(_Right);
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _NODISCARD constexpr bool ends_with(const _Elem* const _Right) const noexcept /* strengthened */ {
    // DEBUG:         return basic_string_view<_Elem, _Traits>{_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize}.ends_with(_Right);
    // DEBUG:     }
    // DEBUG: #endif // _HAS_CXX20
    // DEBUG: 
    // DEBUG: #if _HAS_CXX23
    // DEBUG:     _NODISCARD constexpr bool contains(const basic_string_view<_Elem, _Traits> _Right) const noexcept {
    // DEBUG:         return basic_string_view<_Elem, _Traits>{_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize}.contains(_Right);
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _NODISCARD constexpr bool contains(const _Elem _Right) const noexcept {
    // DEBUG:         return basic_string_view<_Elem, _Traits>{_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize}.contains(_Right);
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _NODISCARD constexpr bool contains(const _Elem* const _Right) const noexcept /* strengthened */ {
    // DEBUG:         return basic_string_view<_Elem, _Traits>{_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize}.contains(_Right);
    // DEBUG:     }
    // DEBUG: #endif // _HAS_CXX23
    // DEBUG: 
    // DEBUG:     _NODISCARD _CONSTEXPR20 allocator_type get_allocator() const noexcept {
    // DEBUG:         return static_cast<allocator_type>(_Getal());
    // DEBUG:     }
    // DEBUG: 
    // DEBUG: private:
    // DEBUG:     _NODISCARD static _CONSTEXPR20 size_type _Calculate_growth(
    // DEBUG:         const size_type _Requested, const size_type _Old, const size_type _Max) noexcept {
    // DEBUG:         const size_type _Masked = _Requested | _Alloc_mask;
    // DEBUG:         if (_Masked > _Max) { // the mask overflows, settle for max_size()
    // DEBUG:             return _Max;
    // DEBUG:         }
    // DEBUG: 
    // DEBUG:         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows
    // DEBUG:             return _Max;
    // DEBUG:         }
    // DEBUG: 
    // DEBUG:         return (_STD max)(_Masked, _Old + _Old / 2);
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _NODISCARD _CONSTEXPR20 size_type _Calculate_growth(const size_type _Requested) const noexcept {
    // DEBUG:         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     template <class _Fty, class... _ArgTys>
    // DEBUG:     _CONSTEXPR20 basic_string& _Reallocate_for(const size_type _New_size, _Fty _Fn, _ArgTys... _Args) {
    // DEBUG:         // reallocate to store exactly _New_size elements, new buffer prepared by
    // DEBUG:         // _Fn(_New_ptr, _New_size, _Args...)
    // DEBUG:         if (_New_size > max_size()) {
    // DEBUG:             _Xlen_string(); // result too long
    // DEBUG:         }
    // DEBUG: 
    // DEBUG:         const size_type _Old_capacity = _Mypair._Myval2._Myres;
    // DEBUG:         size_type _New_capacity       = _Calculate_growth(_New_size);
    // DEBUG:         auto& _Al                     = _Getal();
    // DEBUG:         const pointer _New_ptr        = _Allocate_for_capacity(_Al, _New_capacity); // throws
    // DEBUG: 
    // DEBUG:         _Mypair._Myval2._Orphan_all();
    // DEBUG:         _ASAN_STRING_REMOVE(*this);
    // DEBUG:         _Mypair._Myval2._Mysize = _New_size;
    // DEBUG:         _Mypair._Myval2._Myres  = _New_capacity;
    // DEBUG:         _Fn(_Unfancy(_New_ptr), _New_size, _Args...);
    // DEBUG:         if (_Old_capacity > _Small_string_capacity) {
    // DEBUG:             _Deallocate_for_capacity(_Al, _Mypair._Myval2._Bx._Ptr, _Old_capacity);
    // DEBUG:             _Mypair._Myval2._Bx._Ptr = _New_ptr;
    // DEBUG:         } else {
    // DEBUG:             _Construct_in_place(_Mypair._Myval2._Bx._Ptr, _New_ptr);
    // DEBUG:         }
    // DEBUG: 
    // DEBUG:         _ASAN_STRING_CREATE(*this);
    // DEBUG:         return *this;
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     template <class _Fty, class... _ArgTys>
    // DEBUG:     _CONSTEXPR20 basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {
    // DEBUG:         // reallocate to increase size by _Size_increase elements, new buffer prepared by
    // DEBUG:         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
    // DEBUG:         auto& _My_data            = _Mypair._Myval2;
    // DEBUG:         const size_type _Old_size = _My_data._Mysize;
    // DEBUG:         if (max_size() - _Old_size < _Size_increase) {
    // DEBUG:             _Xlen_string(); // result too long
    // DEBUG:         }
    // DEBUG: 
    // DEBUG:         const size_type _New_size     = _Old_size + _Size_increase;
    // DEBUG:         const size_type _Old_capacity = _My_data._Myres;
    // DEBUG:         size_type _New_capacity       = _Calculate_growth(_New_size);
    // DEBUG:         auto& _Al                     = _Getal();
    // DEBUG:         const pointer _New_ptr        = _Allocate_for_capacity(_Al, _New_capacity); // throws
    // DEBUG: 
    // DEBUG:         _My_data._Orphan_all();
    // DEBUG:         _ASAN_STRING_REMOVE(*this);
    // DEBUG:         _My_data._Mysize      = _New_size;
    // DEBUG:         _My_data._Myres       = _New_capacity;
    // DEBUG:         _Elem* const _Raw_new = _Unfancy(_New_ptr);
    // DEBUG:         if (_Old_capacity > _Small_string_capacity) {
    // DEBUG:             const pointer _Old_ptr = _My_data._Bx._Ptr;
    // DEBUG:             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);
    // DEBUG:             _Deallocate_for_capacity(_Al, _Old_ptr, _Old_capacity);
    // DEBUG:             _My_data._Bx._Ptr = _New_ptr;
    // DEBUG:         } else {
    // DEBUG:             _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);
    // DEBUG:             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);
    // DEBUG:         }
    // DEBUG: 
    // DEBUG:         _ASAN_STRING_CREATE(*this);
    // DEBUG:         return *this;
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _CONSTEXPR20 void _Become_small() noexcept {
    // DEBUG:         // release any held storage and return to small string mode
    // DEBUG:         auto& _My_data = _Mypair._Myval2;
    // DEBUG:         _STL_INTERNAL_CHECK(_My_data._Large_mode_engaged());
    // DEBUG:         _STL_INTERNAL_CHECK(_My_data._Mysize <= _Small_string_capacity);
    // DEBUG: 
    // DEBUG:         _My_data._Orphan_all();
    // DEBUG:         _ASAN_STRING_REMOVE(*this);
    // DEBUG:         const pointer _Ptr = _My_data._Bx._Ptr;
    // DEBUG:         _My_data._Bx._Switch_to_buf();
    // DEBUG:         _Traits::copy(_My_data._Bx._Buf, _Unfancy(_Ptr), _My_data._Mysize + 1);
    // DEBUG:         auto& _Al = _Getal();
    // DEBUG:         _Deallocate_for_capacity(_Al, _Ptr, _My_data._Myres);
    // DEBUG:         _My_data._Myres = _Small_string_capacity;
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _CONSTEXPR20 void _Eos(const size_type _New_size) noexcept { // set new length and null terminator
    // DEBUG:         _ASAN_STRING_MODIFY(*this, _Mypair._Myval2._Mysize, _New_size);
    // DEBUG:         _Mypair._Myval2._Mysize = _New_size;
    // DEBUG:         _Traits::assign(_Mypair._Myval2._Myptr()[_New_size], _Elem());
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _CONSTEXPR20 void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage
    // DEBUG:         auto& _My_data = _Mypair._Myval2;
    // DEBUG:         _My_data._Orphan_all();
    // DEBUG:         if (_My_data._Large_mode_engaged()) {
    // DEBUG:             _ASAN_STRING_REMOVE(*this);
    // DEBUG:             auto& _Al = _Getal();
    // DEBUG:             _Deallocate_for_capacity(_Al, _My_data._Bx._Ptr, _My_data._Myres);
    // DEBUG:             _My_data._Bx._Switch_to_buf();
    // DEBUG:         }
    // DEBUG: 
    // DEBUG:         _My_data._Mysize = 0;
    // DEBUG:         _My_data._Myres  = _Small_string_capacity;
    // DEBUG:         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
    // DEBUG:         _Traits::assign(_My_data._Bx._Buf[0], _Elem());
    // DEBUG:     }
    // DEBUG: 
    // DEBUG: public:
    // DEBUG:     _CONSTEXPR20 void _Orphan_all() noexcept { // used by filesystem::path
    // DEBUG:         _Mypair._Myval2._Orphan_all();
    // DEBUG:     }
    // DEBUG: 
    // DEBUG: private:
    // DEBUG:     _CONSTEXPR20 void _Swap_proxy_and_iterators(basic_string& _Right) noexcept {
    // DEBUG:         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _CONSTEXPR20 _Alty& _Getal() noexcept {
    // DEBUG:         return _Mypair._Get_first();
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _CONSTEXPR20 const _Alty& _Getal() const noexcept {
    // DEBUG:         return _Mypair._Get_first();
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _Compressed_pair<_Alty, _Scary_val> _Mypair;
    // DEBUG: }
    public unsafe partial class BasicString<_Elem, _Traits, _Alloc> : IDisposable
    {
        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::Spout.Std.BasicString<_Elem, _Traits, _Alloc>>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::Spout.Std.BasicString<_Elem, _Traits, _Alloc>>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::Spout.Std.BasicString<_Elem, _Traits, _Alloc> managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::Spout.Std.BasicString<_Elem, _Traits, _Alloc>>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::Spout.Std.BasicString<_Elem, _Traits, _Alloc> managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BasicString<_Elem, _Traits, _Alloc> __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new BasicString<_Elem, _Traits, _Alloc>(native.ToPointer(), skipVTables);
        }

        internal static BasicString<_Elem, _Traits, _Alloc> __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BasicString<_Elem, _Traits, _Alloc>)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BasicString<_Elem, _Traits, _Alloc> __CreateInstance(global::Spout.Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C native, bool skipVTables = false)
        {
            return new BasicString<_Elem, _Traits, _Alloc>(native, skipVTables);
        }

        private static void* __CopyValue(global::Spout.Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Spout.Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C));
            *(global::Spout.Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) ret = native;
            return ret.ToPointer();
        }

        private BasicString(global::Spout.Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BasicString(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        // DEBUG: _CONSTEXPR20
        // DEBUG:     basic_string() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {
        // DEBUG:         _Construct_empty();
        // DEBUG:     }
        public BasicString()
        {
            var ___Elem = typeof(_Elem);
            var ___Traits = typeof(_Traits);
            var ___Alloc = typeof(_Alloc);
            if (___Elem.IsAssignableFrom(typeof(sbyte)) && ___Traits.IsAssignableFrom(typeof(global::Spout.Std.CharTraits<sbyte>)) && ___Alloc.IsAssignableFrom(typeof(global::Spout.Std.Allocator<sbyte>)))
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Spout.Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                global::Spout.Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C.ctorc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C(__Instance);
                return;
            }
            throw new ArgumentOutOfRangeException("_Elem, _Traits, _Alloc", string.Join(", ", new[] { typeof(_Elem).FullName, typeof(_Traits).FullName, typeof(_Alloc).FullName }), "global::Spout.Std.BasicString<_Elem, _Traits, _Alloc> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <sbyte, global::Spout.Std.CharTraits<sbyte>, global::Spout.Std.Allocator<sbyte>>.");
        }

        ~BasicString()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (callNativeDtor)
            {
                var ___Elem = typeof(_Elem);
                var ___Traits = typeof(_Traits);
                var ___Alloc = typeof(_Alloc);
                if (___Elem.IsAssignableFrom(typeof(sbyte)) && ___Traits.IsAssignableFrom(typeof(global::Spout.Std.CharTraits<sbyte>)) && ___Alloc.IsAssignableFrom(typeof(global::Spout.Std.Allocator<sbyte>)))
                {
                    global::Spout.Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C.dtorc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C(__Instance);
                    return;
                }
                throw new ArgumentOutOfRangeException("_Elem, _Traits, _Alloc", string.Join(", ", new[] { typeof(_Elem).FullName, typeof(_Traits).FullName, typeof(_Alloc).FullName }), "global::Spout.Std.BasicString<_Elem, _Traits, _Alloc> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <sbyte, global::Spout.Std.CharTraits<sbyte>, global::Spout.Std.Allocator<sbyte>>.");
            }
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }
    }

    namespace StringVal
    {
        [StructLayout(LayoutKind.Sequential, Size = 32, Pack = 8)]
        public unsafe partial struct __Internal
        {
            internal global::Spout.Std.StringVal.Bxty.__Internal _Bx;
            internal ulong _Mysize;
            internal ulong _Myres;
        }

        namespace Bxty
        {
            [StructLayout(LayoutKind.Explicit, Size = 16, Pack = 8)]
            public unsafe partial struct __Internal
            {
                [FieldOffset(0)]
                internal fixed sbyte _Buf[16];

                [FieldOffset(0)]
                internal __IntPtr _Ptr;

                [FieldOffset(0)]
                internal fixed sbyte _Alias[16];
            }
        }

    }

    public unsafe static partial class BasicStringExtensions
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("Std-symbols", EntryPoint = "?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr Assign(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string _Ptr);

            [SuppressUnmanagedCodeSecurity, DllImport("Std-symbols", EntryPoint = "?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr Data(__IntPtr __instance);
        }

        // DEBUG: _CONSTEXPR20 basic_string& assign(_In_z_ const _Elem* const _Ptr)
        public static global::Spout.Std.BasicString<sbyte, global::Spout.Std.CharTraits<sbyte>, global::Spout.Std.Allocator<sbyte>> Assign(this global::Spout.Std.BasicString<sbyte, global::Spout.Std.CharTraits<sbyte>, global::Spout.Std.Allocator<sbyte>> @this, string _Ptr)
        {
            var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
            var ___ret = __Internal.Assign(__arg0, _Ptr);
            var __result0 = global::Spout.Std.BasicString<sbyte, global::Spout.Std.CharTraits<sbyte>, global::Spout.Std.Allocator<sbyte>>.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        // DEBUG: _CONSTEXPR20 _Ret_z_ const _Elem* data() const noexcept
        public static string Data(this global::Spout.Std.BasicString<sbyte, global::Spout.Std.CharTraits<sbyte>, global::Spout.Std.Allocator<sbyte>> @this)
        {
            var __arg0 = @this is null ? __IntPtr.Zero : @this.__Instance;
            var ___ret = __Internal.Data(__arg0);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
        }
    }
}

namespace Spout.Std
{
    namespace CharTraits
    {
        [StructLayout(LayoutKind.Sequential, Size = 1, Pack = 8)]
        public unsafe partial struct __Internal
        {
        }
    }

    // DEBUG: struct char_traits : _Char_traits<_Elem, long> {}
    public unsafe partial class CharTraits<_Elem> : IDisposable
    {
        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::Spout.Std.CharTraits<_Elem>>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::Spout.Std.CharTraits<_Elem>>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::Spout.Std.CharTraits<_Elem> managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::Spout.Std.CharTraits<_Elem>>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::Spout.Std.CharTraits<_Elem> managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CharTraits<_Elem> __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CharTraits<_Elem>(native.ToPointer(), skipVTables);
        }

        internal static CharTraits<_Elem> __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CharTraits<_Elem>)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CharTraits<_Elem> __CreateInstance(global::Spout.Std.CharTraits.__Internal native, bool skipVTables = false)
        {
            return new CharTraits<_Elem>(native, skipVTables);
        }

        private static void* __CopyValue(global::Spout.Std.CharTraits.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Spout.Std.CharTraits.__Internal));
            *(global::Spout.Std.CharTraits.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CharTraits(global::Spout.Std.CharTraits.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CharTraits(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        ~CharTraits()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }
    }
}

namespace Spout.Std
{
    // DEBUG: using _Rebind_pointer_t = typename pointer_traits<_Ptr>::template rebind<_Ty>
    namespace CompressedPair
    {
        [StructLayout(LayoutKind.Sequential, Size = 32, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_allocator__C___N_std_S__String_val____N_std_S__Simple_types__C_Vb1
        {
            internal global::Spout.Std.StringVal.__Internal _Myval2;
        }
    }

    namespace Allocator
    {
        [StructLayout(LayoutKind.Sequential, Size = 1, Pack = 8)]
        public unsafe partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("Std-symbols", EntryPoint = "??0?$allocator@D@std@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctorc__N_std_S_allocator__C(__IntPtr __instance);
        }
    }

    // DEBUG: class allocator {
    // DEBUG: public:
    // DEBUG:     static_assert(!is_const_v<_Ty>, "The C++ Standard forbids containers of const elements "
    // DEBUG:                                     "because allocator<const T> is ill-formed.");
    // DEBUG:     static_assert(!is_function_v<_Ty>, "The C++ Standard forbids allocators for function elements "
    // DEBUG:                                        "because of [allocator.requirements].");
    // DEBUG:     static_assert(!is_reference_v<_Ty>, "The C++ Standard forbids allocators for reference elements "
    // DEBUG:                                         "because of [allocator.requirements].");
    // DEBUG: 
    // DEBUG:     using _From_primary = allocator;
    // DEBUG: 
    // DEBUG:     using value_type = _Ty;
    // DEBUG: 
    // DEBUG: #if _HAS_DEPRECATED_ALLOCATOR_MEMBERS
    // DEBUG:     using pointer _CXX17_DEPRECATE_OLD_ALLOCATOR_MEMBERS       = _Ty*;
    // DEBUG:     using const_pointer _CXX17_DEPRECATE_OLD_ALLOCATOR_MEMBERS = const _Ty*;
    // DEBUG: 
    // DEBUG:     using reference _CXX17_DEPRECATE_OLD_ALLOCATOR_MEMBERS       = _Ty&;
    // DEBUG:     using const_reference _CXX17_DEPRECATE_OLD_ALLOCATOR_MEMBERS = const _Ty&;
    // DEBUG: #endif // _HAS_DEPRECATED_ALLOCATOR_MEMBERS
    // DEBUG: 
    // DEBUG:     using size_type       = size_t;
    // DEBUG:     using difference_type = ptrdiff_t;
    // DEBUG: 
    // DEBUG:     using propagate_on_container_move_assignment           = true_type;
    // DEBUG:     using is_always_equal _CXX20_DEPRECATE_IS_ALWAYS_EQUAL = true_type;
    // DEBUG: 
    // DEBUG: #if _HAS_DEPRECATED_ALLOCATOR_MEMBERS
    // DEBUG:     template <class _Other>
    // DEBUG:     struct _CXX17_DEPRECATE_OLD_ALLOCATOR_MEMBERS rebind {
    // DEBUG:         using other = allocator<_Other>;
    // DEBUG:     };
    // DEBUG: 
    // DEBUG:     _CXX17_DEPRECATE_OLD_ALLOCATOR_MEMBERS _NODISCARD _Ty* address(_Ty& _Val) const noexcept {
    // DEBUG:         return _STD addressof(_Val);
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _CXX17_DEPRECATE_OLD_ALLOCATOR_MEMBERS _NODISCARD const _Ty* address(const _Ty& _Val) const noexcept {
    // DEBUG:         return _STD addressof(_Val);
    // DEBUG:     }
    // DEBUG: #endif // _HAS_DEPRECATED_ALLOCATOR_MEMBERS
    // DEBUG: 
    // DEBUG:     constexpr allocator() noexcept {}
    // DEBUG: 
    // DEBUG:     constexpr allocator(const allocator&) noexcept = default;
    // DEBUG:     template <class _Other>
    // DEBUG:     constexpr allocator(const allocator<_Other>&) noexcept {}
    // DEBUG:     _CONSTEXPR20 ~allocator()                           = default;
    // DEBUG:     _CONSTEXPR20 allocator& operator=(const allocator&) = default;
    // DEBUG: 
    // DEBUG:     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) noexcept /* strengthened */ {
    // DEBUG:         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
    // DEBUG:         // no overflow check on the following multiply; we assume _Allocate did that check
    // DEBUG:         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {
    // DEBUG:         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
    // DEBUG:         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
    // DEBUG:     }
    // DEBUG: 
    // DEBUG: #if _HAS_CXX23
    // DEBUG:     _NODISCARD_RAW_PTR_ALLOC constexpr allocation_result<_Ty*> allocate_at_least(
    // DEBUG:         _CRT_GUARDOVERFLOW const size_t _Count) {
    // DEBUG:         return {allocate(_Count), _Count};
    // DEBUG:     }
    // DEBUG: #endif // _HAS_CXX23
    // DEBUG: 
    // DEBUG: #if _HAS_DEPRECATED_ALLOCATOR_MEMBERS
    // DEBUG:     _CXX17_DEPRECATE_OLD_ALLOCATOR_MEMBERS _NODISCARD_RAW_PTR_ALLOC __declspec(allocator)
    // DEBUG:     _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count, const void*) {
    // DEBUG:         return allocate(_Count);
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     template <class _Objty, class... _Types>
    // DEBUG:     _CXX17_DEPRECATE_OLD_ALLOCATOR_MEMBERS void construct(_Objty* const _Ptr, _Types&&... _Args) {
    // DEBUG:         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     template <class _Uty>
    // DEBUG:     _CXX17_DEPRECATE_OLD_ALLOCATOR_MEMBERS void destroy(_Uty* const _Ptr) {
    // DEBUG:         _Ptr->~_Uty();
    // DEBUG:     }
    // DEBUG: 
    // DEBUG:     _CXX17_DEPRECATE_OLD_ALLOCATOR_MEMBERS _NODISCARD size_t max_size() const noexcept {
    // DEBUG:         return static_cast<size_t>(-1) / sizeof(_Ty);
    // DEBUG:     }
    // DEBUG: #endif // _HAS_DEPRECATED_ALLOCATOR_MEMBERS
    // DEBUG: 
    // DEBUG:     static constexpr size_t _Minimum_asan_allocation_alignment = _Asan_granularity;
    // DEBUG: }
    public unsafe partial class Allocator<_Ty> : IDisposable
    {
        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::Spout.Std.Allocator<_Ty>>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::Spout.Std.Allocator<_Ty>>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::Spout.Std.Allocator<_Ty> managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::Spout.Std.Allocator<_Ty>>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::Spout.Std.Allocator<_Ty> managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static Allocator<_Ty> __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new Allocator<_Ty>(native.ToPointer(), skipVTables);
        }

        internal static Allocator<_Ty> __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (Allocator<_Ty>)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static Allocator<_Ty> __CreateInstance(global::Spout.Std.Allocator.__Internal native, bool skipVTables = false)
        {
            return new Allocator<_Ty>(native, skipVTables);
        }

        private static void* __CopyValue(global::Spout.Std.Allocator.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Spout.Std.Allocator.__Internal));
            *(global::Spout.Std.Allocator.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Allocator(global::Spout.Std.Allocator.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected Allocator(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        // DEBUG: constexpr allocator() noexcept {}
        public Allocator()
        {
            var ___Ty = typeof(_Ty);
            if (___Ty.IsAssignableFrom(typeof(sbyte)))
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Spout.Std.Allocator.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                global::Spout.Std.Allocator.__Internal.ctorc__N_std_S_allocator__C(__Instance);
                return;
            }
            throw new ArgumentOutOfRangeException("_Ty", string.Join(", ", new[] { typeof(_Ty).FullName }), "global::Spout.Std.Allocator<_Ty> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <sbyte>.");
        }

        ~Allocator()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (callNativeDtor)
            {
                var ___Ty = typeof(_Ty);
                if (___Ty.IsAssignableFrom(typeof(sbyte)))
                {
                    return;
                }
                throw new ArgumentOutOfRangeException("_Ty", string.Join(", ", new[] { typeof(_Ty).FullName }), "global::Spout.Std.Allocator<_Ty> maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <sbyte>.");
            }
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }
    }
}

namespace Spout.Std
{
}

namespace Spout.Std
{
    namespace Chrono
    {
    }
}

namespace Spout.Std
{
}

namespace Spout.Std
{
}

namespace Spout.Std
{
}

// DEBUG: enum DXGI_FORMAT
// DEBUG: {
// DEBUG:     DXGI_FORMAT_UNKNOWN	                                = 0,
// DEBUG:     DXGI_FORMAT_R32G32B32A32_TYPELESS                   = 1,
// DEBUG:     DXGI_FORMAT_R32G32B32A32_FLOAT                      = 2,
// DEBUG:     DXGI_FORMAT_R32G32B32A32_UINT                       = 3,
// DEBUG:     DXGI_FORMAT_R32G32B32A32_SINT                       = 4,
// DEBUG:     DXGI_FORMAT_R32G32B32_TYPELESS                      = 5,
// DEBUG:     DXGI_FORMAT_R32G32B32_FLOAT                         = 6,
// DEBUG:     DXGI_FORMAT_R32G32B32_UINT                          = 7,
// DEBUG:     DXGI_FORMAT_R32G32B32_SINT                          = 8,
// DEBUG:     DXGI_FORMAT_R16G16B16A16_TYPELESS                   = 9,
// DEBUG:     DXGI_FORMAT_R16G16B16A16_FLOAT                      = 10,
// DEBUG:     DXGI_FORMAT_R16G16B16A16_UNORM                      = 11,
// DEBUG:     DXGI_FORMAT_R16G16B16A16_UINT                       = 12,
// DEBUG:     DXGI_FORMAT_R16G16B16A16_SNORM                      = 13,
// DEBUG:     DXGI_FORMAT_R16G16B16A16_SINT                       = 14,
// DEBUG:     DXGI_FORMAT_R32G32_TYPELESS                         = 15,
// DEBUG:     DXGI_FORMAT_R32G32_FLOAT                            = 16,
// DEBUG:     DXGI_FORMAT_R32G32_UINT                             = 17,
// DEBUG:     DXGI_FORMAT_R32G32_SINT                             = 18,
// DEBUG:     DXGI_FORMAT_R32G8X24_TYPELESS                       = 19,
// DEBUG:     DXGI_FORMAT_D32_FLOAT_S8X24_UINT                    = 20,
// DEBUG:     DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS                = 21,
// DEBUG:     DXGI_FORMAT_X32_TYPELESS_G8X24_UINT                 = 22,
// DEBUG:     DXGI_FORMAT_R10G10B10A2_TYPELESS                    = 23,
// DEBUG:     DXGI_FORMAT_R10G10B10A2_UNORM                       = 24,
// DEBUG:     DXGI_FORMAT_R10G10B10A2_UINT                        = 25,
// DEBUG:     DXGI_FORMAT_R11G11B10_FLOAT                         = 26,
// DEBUG:     DXGI_FORMAT_R8G8B8A8_TYPELESS                       = 27,
// DEBUG:     DXGI_FORMAT_R8G8B8A8_UNORM                          = 28,
// DEBUG:     DXGI_FORMAT_R8G8B8A8_UNORM_SRGB                     = 29,
// DEBUG:     DXGI_FORMAT_R8G8B8A8_UINT                           = 30,
// DEBUG:     DXGI_FORMAT_R8G8B8A8_SNORM                          = 31,
// DEBUG:     DXGI_FORMAT_R8G8B8A8_SINT                           = 32,
// DEBUG:     DXGI_FORMAT_R16G16_TYPELESS                         = 33,
// DEBUG:     DXGI_FORMAT_R16G16_FLOAT                            = 34,
// DEBUG:     DXGI_FORMAT_R16G16_UNORM                            = 35,
// DEBUG:     DXGI_FORMAT_R16G16_UINT                             = 36,
// DEBUG:     DXGI_FORMAT_R16G16_SNORM                            = 37,
// DEBUG:     DXGI_FORMAT_R16G16_SINT                             = 38,
// DEBUG:     DXGI_FORMAT_R32_TYPELESS                            = 39,
// DEBUG:     DXGI_FORMAT_D32_FLOAT                               = 40,
// DEBUG:     DXGI_FORMAT_R32_FLOAT                               = 41,
// DEBUG:     DXGI_FORMAT_R32_UINT                                = 42,
// DEBUG:     DXGI_FORMAT_R32_SINT                                = 43,
// DEBUG:     DXGI_FORMAT_R24G8_TYPELESS                          = 44,
// DEBUG:     DXGI_FORMAT_D24_UNORM_S8_UINT                       = 45,
// DEBUG:     DXGI_FORMAT_R24_UNORM_X8_TYPELESS                   = 46,
// DEBUG:     DXGI_FORMAT_X24_TYPELESS_G8_UINT                    = 47,
// DEBUG:     DXGI_FORMAT_R8G8_TYPELESS                           = 48,
// DEBUG:     DXGI_FORMAT_R8G8_UNORM                              = 49,
// DEBUG:     DXGI_FORMAT_R8G8_UINT                               = 50,
// DEBUG:     DXGI_FORMAT_R8G8_SNORM                              = 51,
// DEBUG:     DXGI_FORMAT_R8G8_SINT                               = 52,
// DEBUG:     DXGI_FORMAT_R16_TYPELESS                            = 53,
// DEBUG:     DXGI_FORMAT_R16_FLOAT                               = 54,
// DEBUG:     DXGI_FORMAT_D16_UNORM                               = 55,
// DEBUG:     DXGI_FORMAT_R16_UNORM                               = 56,
// DEBUG:     DXGI_FORMAT_R16_UINT                                = 57,
// DEBUG:     DXGI_FORMAT_R16_SNORM                               = 58,
// DEBUG:     DXGI_FORMAT_R16_SINT                                = 59,
// DEBUG:     DXGI_FORMAT_R8_TYPELESS                             = 60,
// DEBUG:     DXGI_FORMAT_R8_UNORM                                = 61,
// DEBUG:     DXGI_FORMAT_R8_UINT                                 = 62,
// DEBUG:     DXGI_FORMAT_R8_SNORM                                = 63,
// DEBUG:     DXGI_FORMAT_R8_SINT                                 = 64,
// DEBUG:     DXGI_FORMAT_A8_UNORM                                = 65,
// DEBUG:     DXGI_FORMAT_R1_UNORM                                = 66,
// DEBUG:     DXGI_FORMAT_R9G9B9E5_SHAREDEXP                      = 67,
// DEBUG:     DXGI_FORMAT_R8G8_B8G8_UNORM                         = 68,
// DEBUG:     DXGI_FORMAT_G8R8_G8B8_UNORM                         = 69,
// DEBUG:     DXGI_FORMAT_BC1_TYPELESS                            = 70,
// DEBUG:     DXGI_FORMAT_BC1_UNORM                               = 71,
// DEBUG:     DXGI_FORMAT_BC1_UNORM_SRGB                          = 72,
// DEBUG:     DXGI_FORMAT_BC2_TYPELESS                            = 73,
// DEBUG:     DXGI_FORMAT_BC2_UNORM                               = 74,
// DEBUG:     DXGI_FORMAT_BC2_UNORM_SRGB                          = 75,
// DEBUG:     DXGI_FORMAT_BC3_TYPELESS                            = 76,
// DEBUG:     DXGI_FORMAT_BC3_UNORM                               = 77,
// DEBUG:     DXGI_FORMAT_BC3_UNORM_SRGB                          = 78,
// DEBUG:     DXGI_FORMAT_BC4_TYPELESS                            = 79,
// DEBUG:     DXGI_FORMAT_BC4_UNORM                               = 80,
// DEBUG:     DXGI_FORMAT_BC4_SNORM                               = 81,
// DEBUG:     DXGI_FORMAT_BC5_TYPELESS                            = 82,
// DEBUG:     DXGI_FORMAT_BC5_UNORM                               = 83,
// DEBUG:     DXGI_FORMAT_BC5_SNORM                               = 84,
// DEBUG:     DXGI_FORMAT_B5G6R5_UNORM                            = 85,
// DEBUG:     DXGI_FORMAT_B5G5R5A1_UNORM                          = 86,
// DEBUG:     DXGI_FORMAT_B8G8R8A8_UNORM                          = 87,
// DEBUG:     DXGI_FORMAT_B8G8R8X8_UNORM                          = 88,
// DEBUG:     DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM              = 89,
// DEBUG:     DXGI_FORMAT_B8G8R8A8_TYPELESS                       = 90,
// DEBUG:     DXGI_FORMAT_B8G8R8A8_UNORM_SRGB                     = 91,
// DEBUG:     DXGI_FORMAT_B8G8R8X8_TYPELESS                       = 92,
// DEBUG:     DXGI_FORMAT_B8G8R8X8_UNORM_SRGB                     = 93,
// DEBUG:     DXGI_FORMAT_BC6H_TYPELESS                           = 94,
// DEBUG:     DXGI_FORMAT_BC6H_UF16                               = 95,
// DEBUG:     DXGI_FORMAT_BC6H_SF16                               = 96,
// DEBUG:     DXGI_FORMAT_BC7_TYPELESS                            = 97,
// DEBUG:     DXGI_FORMAT_BC7_UNORM                               = 98,
// DEBUG:     DXGI_FORMAT_BC7_UNORM_SRGB                          = 99,
// DEBUG:     DXGI_FORMAT_AYUV                                    = 100,
// DEBUG:     DXGI_FORMAT_Y410                                    = 101,
// DEBUG:     DXGI_FORMAT_Y416                                    = 102,
// DEBUG:     DXGI_FORMAT_NV12                                    = 103,
// DEBUG:     DXGI_FORMAT_P010                                    = 104,
// DEBUG:     DXGI_FORMAT_P016                                    = 105,
// DEBUG:     DXGI_FORMAT_420_OPAQUE                              = 106,
// DEBUG:     DXGI_FORMAT_YUY2                                    = 107,
// DEBUG:     DXGI_FORMAT_Y210                                    = 108,
// DEBUG:     DXGI_FORMAT_Y216                                    = 109,
// DEBUG:     DXGI_FORMAT_NV11                                    = 110,
// DEBUG:     DXGI_FORMAT_AI44                                    = 111,
// DEBUG:     DXGI_FORMAT_IA44                                    = 112,
// DEBUG:     DXGI_FORMAT_P8                                      = 113,
// DEBUG:     DXGI_FORMAT_A8P8                                    = 114,
// DEBUG:     DXGI_FORMAT_B4G4R4A4_UNORM                          = 115,
// DEBUG: 
// DEBUG:     DXGI_FORMAT_P208                                    = 130,
// DEBUG:     DXGI_FORMAT_V208                                    = 131,
// DEBUG:     DXGI_FORMAT_V408                                    = 132,
// DEBUG: 
// DEBUG: 
// DEBUG:     DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE         = 189,
// DEBUG:     DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE = 190,
// DEBUG: 
// DEBUG: 
// DEBUG:     DXGI_FORMAT_FORCE_UINT                  = 0xffffffff
// DEBUG: }
public enum DXGI_FORMAT
{
}

// DEBUG: struct DXGI_RATIONAL
// DEBUG: {
// DEBUG:     UINT Numerator;
// DEBUG:     UINT Denominator;
// DEBUG: }
public unsafe partial class DXGI_RATIONAL
{
    [StructLayout(LayoutKind.Sequential, Size = 8)]
    public partial struct __Internal
    {
        internal uint Numerator;
        internal uint Denominator;
    }
}

// DEBUG: struct DXGI_SAMPLE_DESC
// DEBUG: {
// DEBUG:     UINT Count;
// DEBUG:     UINT Quality;
// DEBUG: }
public unsafe partial class DXGI_SAMPLE_DESC
{
    [StructLayout(LayoutKind.Sequential, Size = 8)]
    public partial struct __Internal
    {
        internal uint Count;
        internal uint Quality;
    }
}
